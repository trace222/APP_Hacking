 Dream-detector
루팅 탐지, 디버깅 탐지, 가상 환경 탐지 등의 기능이 포함되어 있으며, 
악의적인 행위로부터 시스템을 보호할 수 있도록 사용자에게 탐지 내역을 알립니다.

	Check Rooting
		기기가 루팅되었는지 검사합니다.
		Rooting package list check: 루팅 관련 패키지를 검사합니다.
		Rooting binaries list check: 루팅 관련 바이너리를 검사합니다.

	Check Frida
		앱 내에서 프리다가 동작 중인지 검사합니다.
		Frida port check: 프리다가 주로 사용하는 포트 대역을 검사합니다.
		Frida path check: 프리다가 주로 사용하는 경로를 검사합니다.
		Frida module check: 앱 메모리 내에 프리다 모듈이 로드되어있는지 검사합니다.

	Check Emulator
		앱이 에뮬레이터 위에서 동작 중인지 검사합니다.
		Emulator File Check: 에뮬레이터 관련 파일을 검사합니다.
		Emulator Properties Check: 에뮬레이터 관련 시스템 속성을 검사합니다.

	Check Debugging
		앱이 디버깅 중인지 검사합니다.
		Debugging TracerPid check: 앱의 TracerPid를 이용해 디버깅을 검사합니다.
		Debugging Gdb Path Check: gdb가 기기 내에 존재하는지 경로를 검사합니다.
		Debugging Property Check: 디버깅 관련 시스템 속성을 검사합니다.

	TLS Pinner
		인증서 변조를 통한 TLS MITM 공격을 검사합니다.
		서버의 인증서가 Root CA에 의해 신뢰할 수 있는지 검사합니다.
		서버의 인증서가 앱 내에 별도로 고정한 해시와 같은지 검사합니다
	
	frida -D emulator-5554 -f android.com.dream_detector 어태치
	

- Dream-detector 루팅 코드분석
Check Rooting 기능의 UI를 Fragment 객체로 동작(app/src/main/java/android/com/dream_detector/RootingFragment.kt)

	doRootingBinaryCheck 함수
		view 루트 체크 버튼 호출
		버튼 누를시 루팅 여부를 탐지하여 결과를 반환하는 checkSuBinary 함수가 호출
		rootingDetector.checkSuBinary함수를 호출하여 루팅에 사용되는 파일이 기기에 있는지 확인
		확인 결과에 따라 탐지 되었다면 DETECTED!를 출력하고, 탐지되지 않았다면 PASSED.를 출력
		
		디컴파일 시
		Intrinsics.checkNotNullParameter(new RootingDetector(this.getContext()), "$rootingDetector");
            View view0 = this.getView();
            Button t = view0 == null ? null : ((Button)view0.findViewById(0x7F080065));  // id:btnRootingBinariesCheck
            if(new RootingDetector(this.getContext()).checkSuBinary()) {
                if(t != null) {
                    t.setText("Detected!");
                }

                if(t != null) {
                    t.setBackgroundResource(0x7F070061);  // drawable:button_detected
                    return;
                }
            }
			
		원래 코드
		val rootingDetector = RootingDetector(context)
        handler.post {
            val t = view?.findViewById<Button>(R.id.btnRootingBinariesCheck)
            if (rootingDetector.checkSuBinary()) {        
                t?.text = resources.getString(R.string.msg_Detected)
                t?.setBackgroundResource(R.drawable.button_detected)
            } else {	
		
	
	checkSuBinary 함수 분석	
		com/dream_detector/RootDetector.java에 구현
		파일명이 정의된 Constants.knownSuBinaries(su, busybox, magisk)와 파일 경로가 정의된 Constants.knownSuDirectories(/data/local/, /sbin/ 등등) //문자열
		checkSuBinary 함수는 루팅 탐지를 위해 knownSuDirectories에 저장된 경로에 busybox, su, magisk과 같이, knownSuBinaries에 저장된 특정 바이너리가 존재하는지 검사
		
		
		public boolean checkSuBinary() {
		for (String directory : Constants.knownSuDirectories) {
			for (String filename : Constants.knownSuBinaries) { // knownSuDirectories 디렉터리 내 knownSuBinaries 파일이 있는지 확인
				File f = new File(directory, filename);
				if (f.exists()) { // 파일이 있으면 true - 루팅 체크
					return true;
				}}}
		return false;}
		
	탐지 우회
	/data아래에 busybox 파일 생성 detected 설정
	
		함수 반환값 조작
		checkSuBinary는 결국 true/false 반환이므로 반환값 변경
			function modifyCheckSuBinaryRet() {
			Java.perform(function() {
				var rootdector=Java.use("android.com.dream_detector.RootingDetector");
				rootdector.checkSuBinary.implementation=function(){
					return false;
				};
				})
			}
			modifyCheckSuBinaryRet();
			단순 리턴 값 변경
		
	doRootingPackageCheck 함수
		RootingDetector의 checkRootingPackage로 확인
	    if (rootingDetector.checkRootingPackage()) {
		탐지할 패키지 명이 정의된 Constants.knownRootAppsPackages 의 내용을 통하여 확인
			ArrayList<String> packages = new ArrayList<>(Arrays.asList(Constants.knownRootAppsPackages));
		Context 클래스의 getPackageManager 함수를 통해 패키지 매니저 (Package Manager, pm) 객체 생성
			PackageManager pm = mContext.getPackageManager(); 		
		for (String packageName : packages) 을 통하여 패키지명 하나씩 추출
			try {
				pm.getPackageInfo(packageName, 0);
				return true;
			}catch (PackageManager.NameNotFoundException ignore) 
		getPackageInfo함수를 통해 패키지 명에 해당하는 패키지 정보 획득
		설치되지 않았다면 getPackageInfo호출 시 NotFound 예외가 발생
		
	탐지 우회(checkRootingPackage 반환값 변경)
		return false 로 바꾸면 되니 checkSuBinary와 동일
	
	탐지 우회(Constants.knownRootAppsPackages 값 변경)
		function modifyKnownPackagesVal(){
			Java.perform(function(){
				var Constants= Java.use("android.com.dream_detector.Constants");
				//android.com.dream_detector.Constants 클래스에 접근할 수 있도록 Java.use를 사용해 Wrapper를 제공
				var str_arr=Java.array('java.lang.String',[""]);
				//nownRootAppsPackages변수는 문자열 배열이므로 Java.array를 사용하여 새로운 문자열 타입의 배열, 빈 배열지정하여 false 반환
				Constants.knownRootAppsPackages.value=str_arr;// value 지정시 값 지정 가능
			});
		}
		modifyKnownPackagesVal();



- Dream-detector Anti-Frida 포트 우회 코드분석
포트 대역 분석(일반적인 안드로이드 환경에서는 거의 사용하지 않는 포트 대역을 사용)

	
	doFridaPortCheck 코드 분석
		fridaDetector.checkPort 함수를 호출하여 Frida가 사용하는 포트 대역을 확인
		val ret = fridaDetector.checkPort()
		 
		디컴파일코드
		ThreadsKt.thread$default(true, false, null, null, 0, new FridaFragment.doFridaPortCheck.1(this, this.fridaDetector.checkPort()), 30, null);
			doFridaPortCheck.1(this, this.fridaDetector.checkPort())
				=>this.$ret 값으로  this.fridaDetector.checkPort() 결과 값이 전송 (true/false) true이면 디텍트
				if(this.$ret) {
						if(t != null) {
							t.setText("Detected!");
						}
	checkPort 분석
		Socket 객체를 통해 26000부터 27499까지 총 1500개의 포트가 열려있는지 검사
		Frida의 기본 설정 포트는 27042 포트
		public boolean checkPort() {
			int i = 26000;
			while(i < 27500) {
				try {
					boolean z = new Socket("127.0.0.1", i).isConnected();
				}
				catch(IOException iOException0) {
					goto label_8;
				}

				if(z) {
					return true;
				}
	
	탐지우회
		Frida 서버가 어떤 포트를 사용하고 있는지 확인하고, 검사 범위에 포함되는 포트로 서버를 재실행
		Frida 서버가 사용하는 포트 확인
			netstat -ntpl | grep frida
		Frida 서버 실행시 포트 지정
			./frida-server-15.0.8-android-x86_64 -l 0.0.0.0:27000
			
		checkPort 함수 반환값 조작	
			해당 함수가 항상 False를 반환하도록 후킹
			똑같이 Java.use("android.com.dream_detector.FridaDetector");
			FridaDetector.checkPort.implementation = function(){
			해서 우회
		Socket 파라미터 조작
			Socket 클래스의 생성자를 후킹하여 연결을 시도할 주소와 포트를 중간에 변경, 로컬호스트 내의 열려있는 Frida 포트에 아예 접속하지 않도록 하여 우회
			Frida 내에서 클래스의 생성자는 $init을 통해 접근
			checkPort 함수의 경우 문자열과 정수를 인자로 받는 생성자를 사용했기 때문에 overload('java.lang.String', 'int') 를 통해 후킹할 생성자를 선택
			본 함수는 call 함수를 통해 후킹되지 않은 본래의 함수를 호출. 첫 번째 인자로 반드시 this를 넘겨야 합니다.
			function modifySocketParameter(){
				Java.perform(function(){
					var Socket=Java.use("java.net.Socket"); //socket 획득
					var constructor= Socket.$init.overload('java.lang.String','int');// 소켓 생성자 오버로딩
					constructor.implementation =function(hostname,port){ 
						if(hostname=="127.0.0.1" && 26000<= port && port<27500)
						{
							port = 2345; //포트재지정
						}
						return constructor.call(this, hostname, port); // 지정한 포트로 socket 호출
						};});}
			modifySocketParameter();
	
- Dream-detector Anti-Frida 경로 우회
Frida 경로 검사( Frida를 사용할 때 자동으로 생성되는 파일이나 Frida와 관련된 파일들이 저장되어 있는지 검사하여 Frida를 탐지)

	doFridaPathCheck 코드
		fridaDetector.checkPath 함수를 호출하여 Frida와 관련된 파일과 경로를 확인
		ThreadsKt.thread$default(true, false, null, null, 0, new FridaFragment.doFridaPathCheck.1(this, this.fridaDetector.checkPath()), 30, null);
		
	fridaDetector.checkPath 분석
		frida-server파일은 안드로이드 내의 임시 경로인 /data/local/tmp 내에 저장
		Frida 서버가 동작 중일 때에는 자동으로 /data/local/tmp 디렉터리 내에 re.frida.server라는 이름을 가진 디렉터리가 생성
		/data/local/tmp는 일반 앱 권한으로 열람할 수 없는 디렉토리입니다. 따라서 해당 디렉토리에 권한을 부여해야 올바르게 탐지할 수 있습니다.
		
		try {
            AtomicBoolean found = new AtomicBoolean(false);
            Files.list(new File("/data/local/tmp").toPath()).limit(200L).forEach((Path path) -> if(path.toString().contains("frida")) {
                found.set(true); //tmp 폴더 내 반복 찾기, frida 포함된 파일 존재시 true 리턴
            });
            return found.get();
        }
	탐지 우회
		checkPath 함수 반환값 조작
			동일, 해당 함수가 항상 False를 반환하도록 후킹한다면 Frida 관련 파일이 있어도 이를 탐지되지 않은 것처럼 조작
			Java.Use("android.com.dream_detector.FridaDetector");
			FridaDetector.checkPath.implementation=function(){return false;}

		String.contains 함수 파라미터 변조
			frida 라는 문자열이 포함되어 있는지 여부를 통해 결정
			String.contains 함수를 후킹하여 만약 frida 라는 문자열이 파라미터로 전달되면, 이를 조작하여 다른 문자열이 전달
			checkPath 함수의 경우 CharSequence 타입을 인자로 받는 함수를 사용했기 때문에 overload('java.lang.CharSequence') 를 통해 후킹할 함수를 선택
			
			function modifyStrContainsParameter(){
				Java.perform(function(){
					var string_ = Java.use("java.lang.String");
					
					string_.contains.overload('java.lang.CharSequence').implementation=function(s){
					if(s=="frida")
					{	s="**not_exist**";	}
					return string_.contains.overload('java.lang.CharSequence').call(this,s); 
					// 인자가 하나인게 여러개있다보니 명시필요, 이전에 "constructor.call"은 명시안함
					};
				});
			}
			modifyStrContainsParameter();
			
- Dream-detector Anti-Frida 모듈 우회
Frida 모듈 검사 기능은 앱 프로세스 내에 Frida 관련 모듈이 로드되어 있는지 검사
Frida는 앱 프로세스 내 메모리를 간편하게 후킹하기 위해 내부적으로 자체 모듈을 프로세스 내에 로드합니다.
따라서 프로세스의 메모리 맵을 조회했을 때 Frida 관련 모듈이 존재한다면 Frida가 사용 중일 확률

	fridaDetector.checkModule 함수를 호출
	//getFridaDetector().checkModule 로 this.fridaDetector = new FridaDetector(); 해당 FridaDetector 객체 호출
	View view0 = this.getView();
            Button t = view0 == null ? null : ((Button)view0.findViewById(0x7F080061));  // id:btnFridaModuleCheck
            if(this.getFridaDetector().checkModule()) {
                if(t != null) {
                    t.setText("Detected!");
                }
		
	checkModule 함수 분석 
		현재 프로세스의 메모리 맵 정보를 가지고 있는 /proc/self/maps 파일에서 frida 문자열의 여부를 검사
		/proc/self/maps 파일은 보편적으로 어느 공유 라이브러리들이 함께 로드되어있고, 베이스 주소를 찾기 위해 이용
		Frida 서버는 앱 프로세스 내의 frida-agent-{arch}.so 라이브러리를 로드, 따라서 Frida를 통해 실행된 앱은 반드시 메모리 맵 내에 frida 라는 이름이 포함됨
		앱 프로세스의 메모리 맵 파일을 참조하여 Frida가 함께 실행 중인지 탐지
		FileInputStream 클래스와 BufferedReader 클래스를 이용해 해당 파일의 내용을 모두 읽어옴
		frida라는 문자열이 존재하는지 검사, Frida 모듈이 실행중인 것으로 판단하여 True를 반환하고, 문자열이 없다면 False를 반환
		File f = new File("/proc/self/maps"); //맵 파일 열기
			try {
				FileInputStream fio = new FileInputStream(f); // 파일로 부터 바이트로 입력받아, 바이트 단위로 출력할 수 있는 클래스
				StringBuilder resultStringBuilder = new StringBuilder();
				try (BufferedReader br = new BufferedReader(new InputStreamReader(fio))) {// 바이트 읽어와 버퍼에 저장 br
					String line;
					while ((line = br.readLine()) != null) { // 버퍼에서 한줄씩 읽어오기
						resultStringBuilder.append(line).append("\n"); // 한줄씩 저장
					}
	
	탐지우회
		frida -D emulator-5554 -f android.com.dream_detector 를 통하여 실행하여야 탐지돔
		
		checkModule 함수 반환값 조작
		동일
		해당 함수가 항상 False를 반환하도록 후킹
		Java.perform(function(){
		var FridaDetector = Java.use("android.com.dream_detector.FridaDetector"); 
		FridaDetector.checkModule.implementation = funtion(){ return false;}});
		
		BufferedReader.ReadLine 함수 반환값 조작
		BufferedReader.readLine 함수를 후킹하여 반환 값 내에 frida라는 문자열이 포함되어있는지 여부를 조작
		무조건 frida 문자열을 지우도록 후킹하면 앱이 원래 수행해야 하는 동작도 문제가 생길 가능성이 존재
		이를 위해 File 클래스의 생성자를 먼저 후킹한 후, 생성자로 전달된 파일 이름이 /proc/self/maps인 경우에만 BufferedReader.readLine 함수를 후킹
		기존 후킹을 통한 파라미터 변조와 반대로 이번에는 반환 값을 변조해야 하기 때문에 원본 함수를 먼저 호출하고, 반환 값 내에 frida라는 문자열이 존재하는지 검사
		
		function modifyReadLineRet(){
			Java.perform(function() {
				var File = Java.use("java.io.File");
				var constructor = File.$init.overload('java.lang.String');
				var null_flag = false;
				
				constructor.implementation = function(pathname) {
					if (pathname == "/proc/self/maps" && !null_flag) {
						var BufferedReader = Java.use("java.io.BufferedReader");
						var readline = BufferedReader.readLine.overload();
						
						readline.implementation=function(){
							var ret= readline.call(this);// == this.readLine(); , 호출 방식 2가지?
							if (ret === null){
								null_flag = true;
							}
							else if (ret.includes("frida")) {
								ret = "";
							}
							return ret;
						};
					}
					return constructor.call(this,pathname); //return this.$init(pathname);  호출 방식 2가지?
				};
			});
		}
		modifyReadLineRet();
		

-Dream-detector Anti-emulator 속성 검사
뮬레이터 탐지를 위해 시스템 속성을 검사합니다. 디버깅을 수행하기 위해서는 필수적으로 적용되는 시스템 속성들이 있습니다. 
기기의 시스템 속성에서 에뮬레이터 관련 속성 값이 변경되었다면 해당 기기는 에뮬레이터라고 판단
	doEmulatorPropertiesCheck 함수 분석
		EmulatorDetector.checkProperties함수를 호출하여 시스템 속성에 에뮬레이터 관련 속성이 존재하는지 확인
		val emulatorDetector = EmulatorDetector(context)
		 if (emulatorDetector.checkProperties()) {
		디컴파일
		if(new EmulatorDetector(this.getContext()).checkProperties()) {
                if(t != null) {
                    t.setText("Detected!");
                }
	
	checkProperties 함수 분석
		Constants.knownEmulatorProperties에 정의된 에뮬레이터 관련 시스템 속성의 키를 하나씩 propertyName변수로 설정
		시스템 속성 리스트는 Map 형태로 정의되어 있으며 속성 키-값 형태로 선언되어있습니다.
		값이 빈 문자열 ("")인 경우에는 에뮬레이터 환경이 아닌 경우 존재해서는 안되는 시스템 속성을 의미하며, 값이 존재할 때는 시스템 속성이 해당 값을 포함하고 있으면 에뮬레이터임을 의미
		Map<String, String> knownEmulatorProperties = new HashMap<String, String>() {{
			put("init.svc.qemu-props", "");
			put("qemu.hw.mainkeys", "");
			put("qemu.sf.fake_camera", "");
			put("qemu.sf.lcd_density", "");
			put("ro.bootloader", "unknown");
			put("ro.kernel.android.qemud", "");
			put("ro.kernel.qemu.gles", "");
			put("ro.kernel.qemu", "");
			put("ro.product.device", "generic");
			put("ro.product.model", "sdk");
			put("ro.product.name", "sdk");
			put("ro.serialno", "EMULATOR");
		
		Utils.getProp함수에 인자로 propertyName을 전달하여 해당 필드값을 propertyValue 변수에 저장
		Constants.knownEmulatorProperties.get함수에 인자로 propertyName을 전달하여 미리 정의해 둔 시스템 속성 값을 property_seek에 저장
		property_seek가 빈 문자열이고, propertyValue가 빈 문자열이 아니면 시스템 속성 값이 존재한다는 뜻이므로 에뮬레이터라고 판단
		property_seek가 빈 문자열이 아니고, propertyValue가 property_seek의 문자열을 포함하고 있으면 시스템 속성이 에뮬레이터 동작 시 기록되는 값을 포함하고 있다는 의미
			for (String propertyName : Constants.knownEmulatorProperties.keySet()) {
				String propertyValue = Utils.getProp(mContext, propertyName); // 해당하는 실제 속성 값 획득
				String property_seek = Constants.knownEmulatorProperties.get(propertyName); // 내부에 지정된 속성값 (이름- 값 할때 값)
				if ("".equals(property_seek) && !"".equals(propertyValue)) { // 첫번째 체크 값이 ""빈문자열 인 속성에 한하여, 해당 속성의 대한 값이 존재하기만하면 에뮬
					return true;
				}
				if (!"".equals(property_seek)) {// 지정된 속성의 값이 빈문자열이 아닐시 
					assert propertyValue != null;
					if (property_seek != null && propertyValue.contains(property_seek)) { 
					// 해당 속성의 값에 저장된 문자열(ex_"sdk")이 포함되어 있으면 시스템 속성이 에뮬레이터 동작 시 기록되는 값을 포함하고 있다는 의미
						return true;
					}
		Utils의 getProp 함수, android.os.SystemProperties의 get 메소드 호출, propertyName을 이용하여 시스템 속성값을 리턴
		public final class Utils {
			public static String getProp (Context context, String property) {
				try {
					Class class0 = context.getClassLoader().loadClass("android.os.SystemProperties");
					return (String)class0.getMethod("get", String.class).invoke(class0, property);
				}
				catch(Exception exception0) {
					return null;
				}
			}
		

		
	탐지 우회
		AVD는 Qemu를 기반으로 동작하기때문에 에뮬레이터 관련 시스템 속성인 init.svc.qemu-props, qemu.hw.mainkeys, qemu.sf.fake_camera 등의 속성이 존재
		생성 가능 - setprop ro.serialno EMULATOR
		
		함수 반환값 조작
			동일 
			checkProperties함수 자체의 반환값을 False로 고정하여 해당 검사를 우회
				var EmulatorDetector = Java.use("android.com.dream_detector.EmulatorDetector");
				EmulatorDetector.checkProperties.implementation = function() {
				return false;
		
		속성 값 조작
			getProp 함수는 시스템 속성에서 전달받은 인자와 동일한 키를 찾아 해당 키에 대한 값을 반환
			스템 속성에 전달받은 인자와 동일한 키가 없다면 null을 반환
			getProp함수의 반환 값을 정의된 시스템 속성 리스트에 맞춰,
			리스트에 값이 없는 속성 키라면 null을 반환하고, 특정 값이 있는 속성 키라면 특정 값을 포함하지 않는 값을 반환하여 checkProperties함수를 우회
			
			knownEmulatorProperties 지정
			android.com.dream_detector.Utils클래스 내 getProp함수에 접근
			속성 값을 반환해주는 getProp함수에 전달된 인자값이 에뮬레이터 관련 속성인 knownEmulatorProperties의 키와 동일하다면 존재하지 않아야하는 속성의 경우 null을 반환
			속성 값이 지정된 경우 다른 속성 값이 도출될 수 있도록 getProp에 nothing이라는 이름의 속성 값을 가져옴
			
			자바스크립트 테스트 (배열 하면 이름과 값 중 이름만 출력)
			var a= {"test1":1, "test2":2};
			a 
			--> {test1: 1, test2: 2}
			for(var b in a)
				{ console.log(b);}
			-->	test1
				test2
				a.b 하면 1, 2 가 나오나본데 웹에서는 안됨
			
			var knownEmulatorProperties = {
				"init.svc.qemu-props": "",
				...}
			Java.perform(function(){
				var Utils= Java.use("android.com.dream_detector.Utils"); // Utils 자체가 내부에 정의, 
				Utils.getProp.implementation=function(context, property){
					for(var prop in knownEmulatorProperties) // 해당 이름값만 추출
					{
						if(property==prop) //인자로오는 속성명과 해당지정한 속성명 확인
						{
							if(knownEmulatorProperties.prop==""){ return null;} // 해당 속성의 값이 공백이면 null 반환 -> "".equals에서 true가되고 ! 로인하여 false
						}
					}
					return Utils.getProp.call(this, context,"nothing");
					// 기존에는 propertyName이 들어가서 해당 속성 값을 반환하나 "nothing" 속성명이 들어가 값이 존재하지 않고 이로인해 첫번쨰 if도 !true 되서 false, 
					두번째도 propertyValue.contains(property_seek)) 에서 포함안되서 false된다.
				}
			});
			
-Dream-detector Anti-emulator 파일 검사
에뮬레이터에서만 존재하는 파일의 유무를 검사하여 앱이 에뮬레이터에서 동작하고 있는지 판별
	doEmulatorFilesCheck 함수 분석
		EmulatorDetector.checkFiles함수를 호출하여 시스템 내에 에뮬레이터 관련 파일이 존재하는지 확인
		val emulatorDetector = EmulatorDetector(context)
		 if (emulatorDetector.checkFiles()) {
	
	checkFiles 함수 분석
		checkFiles 함수는 오버로딩되어 파라미터를 받지 않는 함수와 문자열 배열 파라미터를 받는 두 개의 함수가 존재
		파라미터를 받지 않는 checkFiles함수는 에뮬레이터용 파일 리스트를 가져와 파라미터를 받는 checkFiles함수로 전달
		파라미터를 받는 checkFiles함수는 반복문을 돌며 파라미터로 전달된 문자열 리스트 중 존재하는 파일이 있는지 검사
		에뮬레이터로는 지니모션, 앤디, 녹스, Qemu가 있습니다. AVD의 경우 Qemu를 사용
		Constants에는 에뮬레이터별로 탐지할 파일들이 정의
		
		public boolean checkFiles() {
			return (this.checkFiles(Constants.knownGenyFiles)) || (this.checkFiles(Constants.knownAndyFiles)) 
			|| (this.checkFiles(Constants.knownNoxFiles)) || (this.checkFiles(Constants.knownQemuPipes)) || (this.checkFiles(Constants.knownx86Files));
		}
		private boolean checkFiles(String[] files) {
			for(int v = 0; v < files.length; ++v) {
				if(new File(files[v]).exists()) {
					return true;
				}
			}

			return false;
		}
	탐지 우회
		함수 반환 값 변조
			인자가 없는 checkfiles 자체를 false를 반환하도록 후킹
			Java.use("android.com.dream_detector.EmulatorDetector")
			EmulatorDetector.checkFiles.overload().implementation = function() {
            return false;
		탐지 파일 리스트 변조
			emulatorDetector.checkFiles 함수가 파라미터를 받는 checkFiles 함수로 파일 리스트를 전달할 때 중간에 후킹하여 존재하지 않는 파일만 모아둔 리스트로 변경
			function modifyCheckFilesParam(){
				Java.perform(function(){
					var emulatordetector= Java.use("android.com.dream_detector.EmulatorDetector");
					var checkfiles = emulatordetector.checkFiles.overload('[Ljava.lang.String;'); 
					
					// [Ljava.lang.String; type 에 ;를 붙이네 배열은 붙이나?
					
					checkfiles.implementation = function(files){
						var tmp_files=["/testtest_1", "/testtest2"];
						return checkfiles.call(this,tmp_files);
					};});}
			modifyCheckFilesParam();
	

- Dream-detector: Debugger TracerPid 검사 우회
TracerPid는 프로세스 상태정보 필드 중 하나로, 해당 프로세스를 디버깅하고 있는 프로세스의 id를 나타냅니다. 
만약 프로세스가 디버깅되고 있지 않다면 TracerPid 필드는 0 입니다. 따라서 TracerPid 가 0이 아니라면 프로세스가 디버깅 상태
	doDebuggingTracerCheck 함수 분석
		debuggingDetector.checkProcStatus함수를 호출하여 TracerPid를 확인
		 val debuggingDetector = DebuggingDetector(context)
		 handler.post {
			val t = view?.findViewById<Button>(R.id.btnDebuggingTracerCheck)
			if (debuggingDetector.checkProcStatus()) {
		
	checkProcStatus 함수 분석
		모든 프로세스의 상태 정보에서 TracerPid 필드를 읽고, 필드 값을 반환하여 디버깅을 탐지
		프로세스의 상태정보를 알 수 있는 /proc/self/status 파일을 불러옴
		파일을 한 줄씩 읽어서 TracerPid 필드를 찾기
		해당 필드가 없거나 TracerPid 값이 0이면 낫 디버깅
		File f = new File("/proc/self/status");
			try {
				FileInputStream fio = new FileInputStream(f);
				try (BufferedReader br
							 = new BufferedReader(new InputStreamReader(fio))) {
					String line;
					while ((line = br.readLine()) != null) { //파일 없으면 나가서 false
						if (line.contains("TracerPid:")) {
							return Integer.parseInt(line.substring(11)) != 0; // 파일 있으면 TracerPid 값 확인(11번째 위치가 값) 
						}
					}
	
			
	탐지 우회
		strace는 프로세스에서 생성하는 시스템 호출, 시스템 호출이 무엇을 반환하는지 확인할 수 있는 디버깅 유틸리티
		strace -fp `pgrep dream_detector` // 앱 디버깅 기본
		
		함수 반환값 조작
			TracerPid의 값을 가져오는 Integer.parseInt(line.substring(11))의 반환값을 0으로 조작하거나,
			checkProcStatus 함수 자체의 반환값을 False로 고정하여 해당 검사를 우회
			
** Boolean 이랑 boolean 이랑 다름 - java.lang.Boolean 이랑 그냥 boolean 반환형

			var DebuggerDetector = Java.use("android.com.dream_detector.DebuggingDetector");
			DebuggerDetector.checkProcStatus.implementation = function() {
				return Java.use("java.lang.Boolean").$new(false);
			
		
		읽어온 파일 내용 조작
			ufferedReader클래스의 readLine 함수를 사용하여 프로세스 상태 정보를 저장하는 /proc/self/status 파일 읽음
			readLine 함수를 후킹하여 읽어온 파일 내용에 "Tracer: 0"이라는 라인을 강제로 주입하면 TracerPid의 값이 0인 것으로 간주
			Java.use 함수를 사용해 Frida 내에서 java.io.File클래스에 접근할 수 있도록 Wrapper를 제공
			File 객체 생성시에 String값이 인자로 전달되면, frida 스크립트로 구현한 생성자를 통해 객체가 생성
			readLine함수를 오버로드하여, 함수 실행 결과에 TracerPid: 0를 추가
			프로세스 상태 정보를 읽어올 때 TracerPid의 값이 항상 0이 되므로 checkProcStatus 함수를 우회
			
			function modifyFileContent(){
				Java.perform(function(){
					var File= Java.use("java.io.File");
					var constructor=File.$init.overload("java.lang.String");
					
					constructor.implementation=function(filename) 
					// 해당 구문만 후킹해도 잘 돌아감, 만약BufferedReader 가 매우 많이 일어날 시 문제있으니 해당 같이 진행 권고
					{
						if(filename=="/proc/self/status")
						{
							var BufferedReader= Java.use("java.io.BufferedReader");
							var readLine=BufferedReader.readLine.overload();
							
							readLine.implementation=function(){
								var ret=readLine.call(this);
								if(ret==null) // 널.includes 에러로 추가
									return ret;
								if(ret.includes("TracerPid:"))
								{
									ret="TracePid: 0";
									console.log(ret);
								}
								return ret;
							};
						}
						console.log(filename);
						return constructor.call(this,filename);
					};
				});
			}
			modifyFileContent();
			
- Dream-detector: Debugger 경로 검사 우회
Debugger 경로 검사 기능은 디버깅 탐지를 위해 디버깅용 파일의 유무를 검사

	doDebuggingGdbPathCheck 함수 분석
		debuggingDetector.checkPath함수를 호출하여 특정 경로에 디버깅용 파일의 유무를 확인
		
	checkPath 함수 분석
		checkPath 함수는 안드로이드 임시 경로에서 디버깅에 사용되는 파일을 탐색하여 디버깅을 탐지
		주로 안드로이드 내의 임시 경로인 /data/local/tmp 디렉토리를 사용
		/data/local/tmp 디렉토리를 File 객체를 통해 접근
		Files.list 함수를 통해 디렉토리 내의 파일 중 gdb라는 문자열을 포함한 파일 이름을 가진 경우 found변수의 값을 true로 세팅
		found 변수값이 True인 경우, gdb문자열이 포함된 파일명을 가진 파일이 탐지된 것으로 간주하여 True를 반환
		
		public boolean checkPath() {
			try {
				AtomicBoolean found = new AtomicBoolean(false);
				Files.list(new File("/data/local/tmp").toPath()).limit(200L).forEach((Path path) -> if(path.toString().toLowerCase(Locale.ROOT).contains("gdb")) {
					found.set(true);
				});
				return found.get();
			}
			catch(IOException iOException0) {
				return false;
			}
		}
	탐지 우회
		함수 반환값 조작
			heckPath 자체의 반환값을 고정적으로 False
			Java.use("android.com.dream_detector.DebuggingDetector");
			DebuggerDetector.checkPath.implementation = function() {
				return false;
		
		검사 파일 경로 조작
			checkPath 함수에서 디버깅 파일의 유무를 검사할 경로에 접근할 때에 File 객체 생성 인자로 경로를 전달
			/data/local/tmp 디렉토리가 아닌 다른 디렉토리로 경로를 조작
			File 객체 생성시에 인자로 전달된 pathname이 /data/local/tmp라면, 후킹하고자 하는 checkProcStatus함수 내의 File 객체 생성 시점과 동일한 시점
			File 객체가 접근하는 경로는 기존의 안드로이드 임시 경로가 아니라 "/not_exists"경로에 접근
			function modifyFilePath(){
				Java.perform(function(){
					var file= Java.use("java.io.File");
					var constructor=file.$init.overload("java.lang.String");
					constructor.implementation=function(filename){
						if(filename == "/data/local/tmp")
							return constructor.call(this,"/not_exists");
						return constructor.call(this,filename);
					};
				});
			}
			modifyFilePath();
			
- Dream-detector: Debugger 속성 검사 우회
Debugger 속성 검사 기능은 디버깅 탐지를 위해 시스템 속성을 검사

	doDebuggingPropCheck 함수 분석
		debuggingDetector.checkProp함수를 호출하여 디버깅 관련 시스템 속성를 확인
	
	checkProp 함수 분석
		checkProp함수는 시스템의 속성을 확인하여 디버깅을 탐지, ro.debuggable이 1이면 디버깅되고 있는 상태, 0이면 디버깅되지 않는 상태
		시스템 속성을 확인하는 getProp함수에 인자로 ro.debuggable을 전달하여 해당 필드값을 property_value 변수에 저장
		property_value 변수가 null이 아니고, 1이면 디버깅 되고 있는 상태로 간주하고 True를 반환
			public boolean checkProp() {
				String s = Utils.getProp(this.mContext, "ro.debuggable");
				return s != null && (s.equals("1"));
			}
	탐지 우회
		AVD에서는 기본적으로 ro.debuggable값이 1로 설정
		AVD에서 시스템 속성은 getprop 명령을 통해 확인 (getprop ro.debuggable)
		ro.debuggable 시스템 속성은 read-only 속성이기 때문에 일반적인 방법으로는 값 변경이 불가능,
		/dev/__properties__/ 에 존재하는 시스템 속성 관련 파일 값을 직접 변경하는 방법을 사용
		시스템 속성 변경 툴 (https://github.com/liwugang/android_properties) 다운로드 및 AVD 기기 내부에 저장, ro.debuggable속성 값을 1로 설정
			/data/local/tmp/system_properties_x86_64 ro.debuggable 1
			set ro.debuggable == 1 success
			[ro.debuggable]:[1]
		
		함수 반환값 조작
			checkProp함수의 반환값이 False라면 디버깅 관련 파일이 탐지되지 않은 것으로 판단
			var DebuggerDetector = Java.use("android.com.dream_detector.DebuggingDetector");
				DebuggerDetector.checkProp.implementation = function() {
					return false;
		함수 인자 조작
			Utils.getProp함수 내 android.os.SystemProperties 속성을 호출하여 읽음
			getProp함수는 시스템 속성에서 전달받은 인자와 동일한 키를 찾아 해당 키에 대한 값을 반환
			동일한 키가 없다면 null을 반환
			존재하지 않는 속성을 전달하면 getProp의 반환값이 null이 되면서 checkProp함수를 우회
			
			function modifyGetPropParam(){
				Java.perform(function(){
					var Utils=Java.use("android.com.dream_detector.Utils");
					var getprop=Utils.getProp.overload("android.content.Context","java.lang.String");
					//Utils.getProp.implementation=function(context,property)
					getprop.implementation=function(context, property){
						if(property=="ro.debuggable")
							return getprop.call(this,context,"not_exist"); //Utils.getProp.call(this, context, "not_exist");
						return getProp.call(this,context,property); //Utils.getProp.call(this, context, property);
					};});}
			modifyGetPropParam();

-Basic TLS Pinning 우회
	서버가 정상적인 서버인지 검사하기 위해 서버의 인증서를 확인
	TLS 프로토콜을 사용하는 통신의 패킷 내용을 확인하고 싶다면 Man In The Middle (MITM) 공격을 통해 중간에서 새롭게 발급된 인증서를 이용해 패킷 내용을 복호화
	TLS Pinning은 이와 같이 중간에서 서버의 인증서를 조작하는 공격을 막기 위해 클라이언트 단에서 인증서를 고정해두는 것을 의미
	TLS 패킷의 내용을 중간에서 획득할 수 있으면 앱 전체를 분석하지 않고도 앱이 서버와 어떤 내용을 주고받는지 알 수 있으며, 패킷을 조작하기에도 굉장히 용이
	패킷 캡처를 허용하지 않는 앱은 인증서 변조를 통한 MITM을 막기 위해 TLS Pinning 기능을 포함
	//아래에서 하는 enhanced는 직접 인증서를 지정하여 피닝하고, 여기서는 RootCA를 이용하여 피닝
	
	안드로이드의 Root CA 인증서를 이용한 TLS Pinning
	doSendAnHttpRequest 함수 분석
		인증서 변조 여부를 탐지하여 결과를 반환하는 doSendAnHttpRequest함수가 호출
		tlsPinnerSender.run 함수를 호출하여 인자로 전달한 URL에 요청을 수행
		서버의 인증서가 변조되었다면 요청에 실패하기 때문에 요청의 응답값을 비교하여 실패했다면 DETECTED!를 출력
		val x = tlsPinnerSender.run("https://dreamhack.io/test1")
		handler.post {
			val t = view?.findViewById<TextView>(R.id.btnTLSTest)
			if (x != null && x.contains("<title>Dreamhack</title>")){  // tlsPinnerSender url 요청에 응답이 null이 아니며, "dreamhack" 타이틀이 포함되어있으면 정상 
				t?.text = resources.getString(R.string.msg_Passed)
				t?.setBackgroundResource(R.drawable.button_passed)
	
	run 함수 분석
		TLSPinnerSender는 TLS pinning을 수행하는 클래스
			TLSPinnerSender() {
				client = new OkHttpClient();
			
			String run(String url) {
				final CountDownLatch latch = new CountDownLatch(1);
				final String [] retValue = new String[1];  //retValue변수는 서버로의 요청에 대한 응답을 저장해야하므로 String 타입으로 생성               
				Thread t = new Thread("TLS Pinner Thread - 1"){     //서버로 요청을 보내는 동작은 네트워크 환경/기기 환경에 따라 응답까지 소요되는 시간이 상이하기 때문에 스레드로 동작        
					public synchronized void run(){
						retValue[0] = null;
						Request request = new Request.Builder()             
								.url(url) 
								.build();//함수의 인자로 전달받은 url을 사용하여 Request객체를 생성
						try (Response response = client.newCall(request).execute()) { //client 객체를 통해 전달받은 url로 요청을 전송           
							retValue[0] = Objects.requireNonNull(response.body()).string(); //요청 전송에 대한 결과값의 body 부분을 retValue[0]에 String 타입으로 저장
						} catch (Exception ignore) {
						}
						latch.countDown();
					}
				};
				t.start(); // 스레드 시작
				try {
					latch.await(); //스레드 대기
				} catch (InterruptedException ignore) {
				}
				return retValue[0];
				
	탐지 우회
		
		Root CA 체인을 통한 서버 인증서 검증 함수 반환값 조작
			okhttp3가 TLS 프로토콜을 통해 통신을 시작할 때 내부적으로 TLS Handshake를 수행합니다. 이 과정에서 서버의 인증서를 신뢰할 수 있을지 검사하기 위해 기기의 Root CA 체인을 이용합니다. 
			com.android.org.conscrypt.TrustManagerImpl.getTrustedChainForServer 함수는 Root CA를 이용해 서버의 인증서 체인을 신뢰할 수 있을지 검사
			 - 그냥 인증시 저 함수를 호출 개인 함수x
			함수는 인자로 전달된 서버 인증서 체인 (certs)을 신뢰할 수 있는지 검사
			신뢰할 수 있다면, 인증서 체인을 반환
			신뢰하는 체인이 아닐 경우, CertificateException 익셉션이 발생
			함수를 후킹하여 첫 번째 인자로 전달된 certs 리스트를 그대로 반환하기만 한다면 이를 신뢰할 수 있는 인증서로 판단하게 되어 Root CA 체인 검증을 우회
				public List<X509Certificate> getTrustedChainForServer(X509Certificate[] certs,
					String authType, Socket socket) throws CertificateException {
						SSLSession session = null;
						SSLParameters parameters = null;
			com.android.org.conscrypt.TrustManagerImpl.getTrustedChainForServer 함수에서 서버의 인증서를 신뢰할 수 있는지 검사
			해당 함수의 반환 값은 신뢰하는 인증서 체인을 의미
			인자로 전달된 서버의 인증서 체인을 그대로 반환해주면, 서버의 인증서를 신뢰하는 것으로 조작
			
			함수의 반환값이 인자로 전달된 certs를 그대로 반환하도록 후킹
			certs의 타입은 X509Certificate[]로 배열이고, 반환 타입은 List<X509Certificate>로 리스트이기 때문에 배열을 리스트로 변환해주는 과정이 필요
			Java.use 함수를 이용해 Arrays 클래스의 Wrapper를 제공받고, Arrays.asList 함수를 이용해 리스트를 배열로 변환
			    Java.perform(function () {
				var TrustManagerImpl = Java.use("com.android.org.conscrypt.TrustManagerImpl");
				var Arrays = Java.use("java.util.Arrays");
				TrustManagerImpl.getTrustedChainForServer.overload('[Ljava.security.cert.X509Certificate;', 'java.lang.String', 'java.net.Socket')
				.implementation = function(certs, authType, socket) {
					return Arrays.asList(certs);//certs 가 그냥 ROOT CA이니 그대로 반환
				}
			
			
		SSLContext.init 후킹을 통한 PortSwigger 인증서 신뢰
			Basic TLS Pinning 검사는 기본적으로 서버의 인증서가 신뢰할 수 있는 CA 목록에 있는지의 여부를 기반으로 검사
			SSLContext.init 함수를 후킹하여 PortSwigger CA를 신뢰
			PortSwigger의 인증서를 이용해 직접 TrustManager를 생성하고, SSLContext.init 함수가 호출되는 시점에 해당 TrustManager로 파라미터를 바꾸는 방식으로 후킹이 가능
			
			SSLContext.init 함수를 통해 초기화할 때 파라미터에 PortSwigger 인증서를 이용해 생성한 TrustManager를 전달하도록 후킹하는 함수
			modifyRootCA 함수는 파라미터로 PortSwigger CA
			이후 CA 파일을 TrustManager 형태로 변환하는 과정이 필요
				https://developer.android.com/training/articles/security-ssl?hl=ko#UnknownCa 
				마지막 39번째 줄에서 SSLContext.init의 implementation을 덮어 TrustManager의 파라미터 값을 
				PortSwigger CA로 생성한 TrustManager를 넘겨 PortSwigger CA를 신뢰할 수 있도록 조작
				function modifyRootCA(cert) {
					Java.perform(function () {
						try {
							var CertificateFactory = Java.use("java.security.cert.CertificateFactory");
							var FileInputStream = Java.use("java.io.FileInputStream");
							var BufferedInputStream = Java.use("java.io.BufferedInputStream");
							var X509Certificate = Java.use("java.security.cert.X509Certificate");
							var KeyStore = Java.use("java.security.KeyStore");
							var TrustManagerFactory = Java.use("javax.net.ssl.TrustManagerFactory");
							var SSLContext = Java.use("javax.net.ssl.SSLContext");
							var cf = CertificateFactory.getInstance("X.509");
							var caInput = BufferedInputStream.$new(FileInputStream.$new(cert));
							var ca = cf.generateCertificate(caInput);
							console.log("ca=" + Java.cast(ca, X509Certificate).getSubjectDN());
							caInput.close();
							var keyStoreType = KeyStore.getDefaultType();
							var keyStore = KeyStore.getInstance(keyStoreType);
							keyStore.load(null, null);
							keyStore.setCertificateEntry("ca", ca);
							
							var tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
							var tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
							tmf.init(keyStore);
							var SSLContext_init = SSLContext.init.overload("[Ljavax.net.ssl.KeyManager;", "[Ljavax.net.ssl.TrustManager;", "java.security.SecureRandom");
							SSLContext_init.implementation = function(km, tm, random) {
								SSLContext_init.call(this, km, tmf.getTrustManagers(), random);
							}
						}
						catch (err) {
							console.log(err);
						}
					});
				}
				modifyRootCA("/data/local/tmp/cacert.der")
			

-Enhanced TLS Pinning 우회
TLS Pinning 기법 중 클라이언트가 지정한 서버의 CA 인증서를 이용한 TLS Pinning을 알아보고, 이를 우회
	doSendAnEnhancedPinningHttpRequest 함수 분석 
		tlsPinnerSender.enhancedRun 함수를 호출하면서 https://dreamhack.io/test1를 인자로 전달하여 TLS pinning 여부를 확인
		x가 <title>Dreamhack</title>을 포함할 경우 클라이언트가 지정된 서버의 인증서를 잘 사용하고 있는 것으로 판단하고 PASSED.를 출력
		만약 x가 null이거나 <title>Dreamhack</title>을 포함하지 않는 경우,
		클라이언트가 지정된 인증서 외에 다른 인증서를 사용하거나 인증서를 사용하고 있지 않은 것으로 판단하여 DETECTED!를 반환
			  val x = tlsPinnerSender.enhancedRun("https://dreamhack.io/test1")
				handler.post {
					val t = view?.findViewById<TextView>(R.id.btnEnhancedTLSTest)
					if (x != null && x.contains("<title>Dreamhack</title>")) {
						t?.text = resources.getString(R.string.msg_Passed)
						t?.setBackgroundResource(R.drawable.button_passed)
		
	enhancedRun 함수 분석
		TLSPinnerSender클래스내 함수
		enhancedRun함수는 okhttp의 CertificatePinner 를 통해 클라이언트의 인증서를 지정
		TLSPinnerSender클래스의 생성자로, doSendAnEnhancedPinningHttpRequest 함수에서 객체 생성시에 동작
		
			public TLSPinnerSender() {
				client = new OkHttpClient();
				certificatePinner = new CertificatePinner.Builder().add("dreamhack.io", "sha256/QnvZVPjqAxkt5Rnr/bI96PF6dFJal/p6sGBUprcSynQ=").build();
				enhancedClient = new OkHttpClient.Builder().certificatePinner(certificatePinner).build();
			enhancedClient에는 클라이언트에 고정할 서버의 호스트와 인증서 정보가 포함
			CertificatePinner 객체를 생성 시 인증서을 지정할 서버의 호스트 정보와 인증서 해시를 인자로 전달
			sha256/QnvZVPjqAxkt5Rnr/bI96PF6dFJal/p6sGBUprcSynQ= 인증서만을 통해 접근
			certificatePinner객체를 OkHttpClient객체 생성시 인자로 사용
			이를 통해 enhancedClient를 사용하여 dreamhack.io로 요청을 보낼때는 지정된 인증서를 사용해야만 정상적인 응답을 받을 수 있다.
		
		
		okhttpclient의 객체인 enhancedClient를 통해 서버의 인증서를 가지고 있어야만 클라이언트가 서버와 통신할 수 있도록 인증서를 고정(pinning)하여,
		서버의 인증서와 동일하다면 정상적인 요청에 대한 결과값을 반환
			String enhancedRun(String url) {
				final CountDownLatch latch = new CountDownLatch(1);
				final String [] retValue = new String[1]; //응답을 저장해야하므로 String 타입으
				Thread t = new Thread("TLS Pinner Thread - 2"){ //스레드 생성
					public synchronized void run(){
						retValue[0] = null;
						Request request = new Request.Builder().url(url).build();  // 전달받은 url을 사용하여 Request객체를 생성
						try (Response response = enhancedClient.newCall(request).execute()) { //dreamhack.io서버의 인증서가 동일한지 검사, 요청 전송 , basic은 여기서 client.newcall
							retValue[0] = Objects.requireNonNull(response.body()).string();//요청 전송에 대한 결과값의 body 부분을 반환
						} catch (Exception ignore) {
						}
						latch.countDown();
					}
				};
				t.start();
				try {
					latch.await();
				} catch (InterruptedException ignore) {
				}
				return retValue[0]
		
	탐지 우회
		함수 반환값 조작
			doSendAnEnhancedPinningHttpRequest함수에서 enhancedRun함수의 반환값이 
			<title>Dreamhack</title>를 포함하고 있는지 검사하여 TLS pinning의 성공여부를 확인
			retValue[0]가 <title>Dreamhack</title>를 항상 포함하도록 enhancedRun함수를 후킹
				function modifyEnhancedRunRet() {
					Java.perform(function() {
						var TLSPinnerSender = Java.use("android.com.dream_detector.TLSPinnerSender");
						var str = Java.use('java.lang.String');
						str = "<title>Dreamhack</title>"
						TLSPinnerSender.enhancedRun.implementation = function(url) {
							return str;
						}
					});
				}
			
		인증서 검사 함수 조작
			enhancedRun함수는 요청 전송 시에 지정된 인증서와 동일한 인증서가 맞는지 검사하기위해 enhancedClient를 사용
			okhttp의 CertificatePinner.check함수를 사용하여 고정된 인증서와 요청 전송 시 인증서를 비교
			CertificatePinner.check함수는 검사에 성공할 경우 null을 반환
			CertificatePinner.check의 반환값을 항상 null로 고정하면 해당 검사를 우회
				function modifyCertificateCheckRet() {
					Java.perform(function() {
						var CertificatePinner = Java.use("okhttp3.CertificatePinner");
						CertificatePinner.check$okhttp.overload('java.lang.String', 'kotlin.jvm.functions.Function0').implementation 
						= function(p0, p1){
							return;
						};
				}
		//
		//kotlin.jvm.functions.Function0 이런거는 Function0이거 선언부 들가면 package kotlin.jvm.functions; 있음 이거 연결


Bypass Packages
		Bypass Packages 항목은 디바이스에 설치된 애플리케이션 패키지 목록을 검사해 루팅 시 설치되는 알려진 패키지 목록들이 존재하는지 검사하고 패키지 존재 시 루팅 디바이스로 판단해 탐지
		
		isCheckRootingInstalled() 함수는 Bypass Packages 탐지 결과를 반환해 주는 역할을 한다. 
		코드를 보면 ①에서 [그림 7]의 rootingPackages에서 패키지 목록을 가져오고 있으며 ② getPackagesInfoCompat() 함수를 통해 가져온 패키지 정보를 반환
		
		while문 조건 구문이며 v4, v2 레지스터리에 저장된 값을 비교해 v3 값이 v1 보다 클 경우 38로 분기된다. 반대로 v3 값이 v1 보다 작을 경우 0x00000012 ~ 0x00000028 주소까지 구문들이 동작해 패키지 검사
		탐지 우회를 위해서는 해당 조건 구문을 참으로 만들어야 하기 때문에 [표 4]를 참고해 조건식을 수정해주면 된다. 여기서는 if-ge를 if-le로 수정
	
	Bypass Binaries
		아래와 같은 세 가지 후킹 포인트가 존재하며, 여기서는 세 번째 File 클래스의 exists() 함수 후킹 방법을 사용하겠다. 
		첫 번째는 함수 결과와 상관없이 무조건 false를 반환하도록 isCheckRootingBinary() 함수를 재 작성하는 방법이고 
		두 번째는 File 클래스 객체 생성 시 전달되는 인수 값인 rootingPath, rootingBinaries를 더미 값으로 변조하는 방법이다.
		그리고 세 번째는 File 클래스의 exists() 함수를 후킹해 반환 값을 변조하는 방법
		
		exists 를 다하지않고 해당 바이너리 에서만 하기
		Java.perform(function(){
			const rootBinaries=["su",...];
			const fileClass = Java.use("java.io.File");
			fileClass.exists.implementation=function(){
				const fileName=fileClass.getName(this)
				const existResult= (rootBinaries.indexOf(fileName)> -1)
				if(existResult){
					return false
				}
				else {return this.exists.call(this);}
			}
			
		});
	
	Bypass Command Execution
		which 명령어를 통해 PATH 변수에 등록된 디렉터리 경로에 su 명령어가 존재하는지 검사하고 명령어 존재 시 루팅 디바이스로 판단해 탐지
		 isCheckRootingExec() 함수는 Bypass Command Execution 탐지 결과를 반환해 주는 역할을 한다. 코드를 살펴보면 Runtime.getRuntime().exec() 
		 함수가 사용된 것을 볼 수 있는데 Runtime.exec()는 Windows, Linux, Unix 등의 시스템 명령어를 Java를 통해 실행한 후 그 결과를 받아오는 기능
		 
		 첫 번째는 함수 결과 상관없이 무조건 false를 반환하도록 isCheckRootingExec() 함수를 재 작성하는 방법이고 
		 두 번째는 Runtime 클래스의 exec() 함수 호출 시 전달되는 인수 값을 더미 값으로 변조하는 방법이
		 perform
		 const runtimeclass=Java.use("java.lang.Runtime");
		 const runtimeExec = runtimeclass.exec.overload("[Ljava.lang.String");
		 runtimeExec.implementation=function(STR){
			STR.forEach(function(it){
				if(it.includes("su")){
					const fakestrarray=["fakeExcution"]
					str = fakestrarray}
			})
			return runtimeExec.CALL(this,STR)
			
		 }
	
	Bypass Build-Tags
		ypass Build-Tags 탐지 항목은 Android 시스템 파일인 build.prop 파일의 시스템 속성 값을 검사하고 비정상 값 존재 시 루팅 디바이스로 판단해 탐지
		스템 속성 값은 ro.build.type, ro.build.tags, ro.build.display.id, ro.build.description, ro.build.fingerprint 등이 있으며, 디바이스 콘솔에서 
		getprop 명령어를 통해 확인이 가능
		isCheckRootingKeys() 함수는 Bypass Module 탐지 결과를 반환해 주는 역할을 한다. 코드를 살펴보면 위에서 언급한 시스템 속성 값인 
		ro.build.type, ro.build.keys 등이 getSystemProperty 클래스의 prop() 함수 호출 시 인수 값으로 사용되고 있으며, 
		결과 반환 값은 arrayList0 리스트 변수에 저장된다. 그 후 contains() 함수를 통해 반환 값 중 test-keys 와 일치하는 문자열이 있는지 검사
		
		첫 번째는 함수 결과 상관없이 무조건 false를 반환하도록 isCheckRootingKeys() 함수를 재 작성하는 방법이고 
		두 번째는 prop 함수 호출 시 인수 값으로 전달되는 문자열을 변조하는 방법
		
		perform
		const array0f=["ro.build.type... (keys,tags,description,fingerprint ...)"]
		const systempropertyclass= Java.use("com.playground.anditer.getSystemProperty");
		systempropertyclass.prop.implementation=function(str){
				arrayOf.forEach(function(it){
				if(str==it){
				str="fakevalue"}
		})
			return prop.call(this,str)
		}
	
	
	Bypass Writeable
		시스템 디렉터리의 권한을 검사하고 일반 사용자 권한에 쓰기 권한이 부여되어 있을 경우 루팅 디바이스로 판단해 탐지
		사용 디바이스에 따라 탐지되는 사람이 있고 탐지되지 않는
		Android 디버그 브리지는 Android 디바이스와 통신하며, 디버깅 등의 작업과 애플리케이션 설치, 디바이스 설정 확인, 시스템 log 출력 등의 작업을 할 수 있도록 지원하는 다목적 명령줄 도구
		Android 디버그 브리지를 통해 설정을 변경
		
		반복문을 통해서 writeAbleFiles 변수에 저장된 디렉터리를 하나씩 확인한다. 이때,
		②에서 Files 클래스를 사용해 권한을 확인하는데 파일의 권한을 가져오는 함수가 바로 getPosixFilepermissions() 함수이다.
		반환되는 권한 값에서 OTHERS_WRITE 문자열이 존재할 경우 루팅 디바이스로 판단해 탐지
		
		첫 번째는 함수 결과 상관없이 무조건 false를 반환하도록 isCheckRWFile() 함수를 재 작성하는 방법이고 
		두 번째는 getPosixFilePermissions() 함수 호출 시 전달되는 인수 값을 더미 값으로 변조하는 방법이다. 
		세 번째는 디렉터리 객체를 반환 받기 위해 사용되는 Paths 클래스의 get() 함수를 후킹해 함수로 들어오는 매개 변수 값을 더미 값으로 변조하는 방법
		
		const path= Java.use("java.nio.file.Paths");
		var get =path.get.overload("java.lang.String","[Ljava.lang.String");
		get.implementation=function(str1,str2){
			str="test"
			return get.call(this,str1,str2)
		}
		
	Bypass System Property
		첫 번째 방법은 Android 9.0 이하에서 사용 가능한 방법이다. Android OS에는 build.prop 설정을 변경하기 위한 setprop이라는 명령어가 존재하는데
		현재는 Android OS 보안 정책에 의해 해당 명령어를 사용하더라도 값이 변경되지 않는다. 하지만, 별도의 바이너리 패치를 적용하면 setprop 명령어를 통해서 속성 값 변경이 가능해진다
		패치 파일은 아래의 https://github.com/jedy/mprop 링크를 통해 다운로드 및 사용법을 참고하면 된다. 
		추가로 시스템 속성 값을 변경하기 앞서 주의할 점이 있는데 ro.secure 값이 1이 아닌 다른 값으로 변경될 경우 USB 인식, 부팅 관련 문제가 발생할 수 있다. 
		따라서, 값 변경 시 ro.secure 값은 변경하지 않고 ro.adb.secure 값만 0으로 변경
		
		두 번째 방법은 Android 5.0 이상에서 사용 가능하며, Magisk를 이용한 방법이다. Magisk는 https://github.com/topjohnwu/Magisk링크에서 Github에서 다운로드해 설치하면 된다.
		Magisk 설치가 완료되었다면, 디바이스에 접속해 props 명령을 실행한다. 그러면 [그림 39]와 같은 화면이 출력되며 5번을 선택해 시스템 설정 페이지로 이동
		새로운 시스템 설정을 위해 n을 선택해 [그림 40]과 같이 New custom prop 설정 페이지로 이동
		변경을 원하는 시스템 속성 이름은 [그림 41]과 같이 입력한다. 여기서는 ro.adb.secure를 입력
		시스템 속성 값 변경 
		확인 페이지가 출력되면 y를 선택하고, 변경을 원하는 값을 입력해 주면 된다. 
		ro.adb.secure 값을 0으로 변경해 줘야 하기 때문에 여기서는 0을 입력하면 된다. 그 후 디바이스 재 부팅이 진행되고 변경된 값이 시스템 설정에 적용
		0이라면 루팅 디바이스로 탐지
		
		Bypass System Property 탐지를 우회하기 위한 후킹 포인트는 세 가지가 있다. 첫 번째는 함수 결과 상관없이 무조건 false를 반환하도록 isCheckForProps() 함수를 재 작성하는 방법이고
		두 번째는 Bypass Build-Tags 항목을 우회하기 위해 사용했던 방법과 동일하게 getSystemProperty 클래스의 prop() 함수로 들어오는 매개 변수를 더미 값으로 변조하는 방법이다. 
		그리고 세 번째는 equals() 함수를 후킹해 결괏값을 false로 반환하게 만드는 방법
		
		const detec=Java.use("~");
		detec.isCheckForProps.implementation=function(){
		return false;
		}
		
	 Bypass Check Process
		관리자 권한을 필요로 하는 루팅 전용 애플리케이션들로 Magisk Manager, MT Manager, Game Guardian 등
		ps –ef 문자열을 isRootCommand() 함수의 인수 값으로 전달해 그 결괏값을 반환받고 있다. 
		②에서는 contains() 함수를 통해 반환받은 결괏값이 magisk라는 문자열이 포함되어 있는지 검사
		 Android OS 버전이 업그레이드되면서 보안 모델도 함께 강화되어 이제는 일반 사용자 권한으로 확인이 불가해졌다. 때문에, 
		 위 [그림 48] 코드에서 프로세스 목록 확인을 위해 su 명령어가 사용됐지만 상용 애플리케이션에서는 이와 같은 방법보다는 
		 su 명령어 사용 가능 유무를 통해 루팅 디바이스를 탐지하는 경우가 더 많다
		 
		첫 번째는 함수 결과 상관없이 무조건 false를 반환하도록 isCheckRootingProcesses() 함수를 재 작성하는 방법이고 
		두 번째는 equals() 함수 호출 시 전달되는 인수 값을 변조하는 방법이다.
		그리고 세 번째는 isRootComm and() 함수의 매개 변수로 들어오는 문자열을 검사해 ps –ef일 경우 더미 값으로 변조하는 방법

		perform
		const roottools=Java.use("~");
		const isRootCommand=roottools.isRootCommand.overload("java.lang.String");
		isRootCommand.implementation=function(str){
			if(str == "ps -ef"){
				return isRootCommand.call(this,"test");
			}
			return isRootCommand.call(this,str)
		}

디버깅
	디버그 사용을 위한 사전 조건
		애플리케이션을 디버그 하기 위해서는 두 가지 전제조건이 필요하다. 
		첫 번째는 분석 대상의 AndroidManifest.xml 파일에 디버그 허용 옵션(debuggable)이 설정되어 있거나, 
		두 번째는 모바일 디바이스 자체 내에서 디버그 모드 지원 관련 시스템 설정이 되어 있어야 한다.
		(ndroid 시스템 파일인 build.prop의 빌드 속성 중 ro.debuggable 값을 1로 변경해 사용)
	
	Bypass TracerPID
		TracerPid는 실행 중인 프로세스의 상태 정보를 나타내는 상태 필드 중 하나로 해당 프로세스를 디버깅하고 있는 프로세스의 아이디(Pid)를 표시한다.
		만약 디버깅하고 있는 프로세스가 존재하지 않는다면 0으로 표기
		동작 중인 프로세스 정보는 /proc 디렉터리에 저장되며, 디바이스 콘솔에서 “cat /proc/[PID]/status” 명령으로 확인하고자 하는 애플리케이션에 관한 프로세스 상태 정보 열람이 가능
		 
		isCheckDebggerState() 함수는 Bypass TracerPID 탐지 결과를 반환해 주는 역할을 한다.
		코드를 살펴보면 ①에서 File 클래스를 사용해 TracerPid 상태 필드가 저장되어 있는 /proc/self/status 파일 객체를 생성한다.
		② ①에서 생성한 파일 객체를 읽어와 contains() 함수를 사용해 TracerPid 문자열이 포함되어 있는지 확인한다. 
		③ 해당 문자열이 포함되어 있다면 split() 함수를 통해 TracerPid 값을 가져와 0과 비교해 Pid 값이 0이 아니라면 디버그가 동작 중인 것으로 판단
		
		첫 번째는 함수 결과와 상관없이 무조건 false를 반환하도록 isCheckDebggerState() 함수를 재 작성하는 방법이고
		두 번째는 File 클래스가 객체를 생성할 때 인자로 전달하는 문자열을 더미 값으로 변조하는 방법과 exists() 함수를 후킹하는 방법이다. (ex- Bypass Binaries)
		마지막 세 번째는 contains() 함수의 인자 값을 변조하는 방법
		
		const fileclass=Java.use("java.io.File");
		const File = fileClass.$init.overload('java.lang.String');
		
		File.implementation=function(path){
			if(path =="/proc/self/status")
			{	return File.call(this,"fake");
			}
			return File.call(this,path);
			}
	
	Bypass Debuggable
		 ro.debuggable 빌드 속성 값을 확인해 값이 1인 경우 애플리케이션이 디버그 모드로 동작 중인 것으로 판단
		 build.prop 파일은 Android OS 운영체제에서 사용되는 빌드 정보 및 시스템 속성이 포함된 파일로 디바이스 부팅 시 로드 된다.
		 파일은 /system 디렉터리 내에 위치하고 있으며 디바이스 콘솔에서 getprop 명령어를 통해 확인이 가능
		 
		  isCheckDebuggable() 함수는 Bypass Debuggable 탐지 결과를 반환해 주는 역할을 한다. 
		  코드를 보면 getSystemProperty 클래스의 prop() 함수가 사용됐으며, 해당 함수의 인자로 전달되는 시스템 속성 값을 반환한다.
		  그 후 equals() 함수를 통해 반환받은 ro.debuggable 빌드 속성 값이 1인지 검증
		  
		  . 첫 번째는 함수 결과와 상관없이 무조건 False를 반환하도록 isCheckDebuggable() 함수를 재 작성하는 방법이고
		  두 번째는 getSystemProperty 클래스의 prop() 함수로 전달되는 인자 값을 변조하는 방법이다.
		  그리고 세 번째는 속성 값 검증을 위해 equals() 함수의 인자로 전달되는 문자열을 변조하는 방법
		  
		  const Stringskt= Java.use("kotile.text.StringsKt__StringsJVMKt");
		  const equals= Stringskt.equlas.overload(~"boolena");
		  equals.implementation=function(str1,str2,bool){
		  if(str2=="1"){str="fake"}
		  return equals.call(this,str1,str2,bool);
		  }
		  
	
	
	Bypass Debug Tools
		 디버그 하고 있는 프로세스의 Pid를 표시하는 상태 필드인 TracerPid 값을 확인하거나 각 도구들이 사용하는 에이전트들의 특징을 캐치하는 방법이 있다. 
		  IDA 도구를 이용한 디버그 모드 사용 예시로 그림과 같이 애플리케이션의 상태 필드인 TracerPid 값이 디버그 하고 있는 에이전트의 프로세스 Pid 값으로 변경된 것을 확인
		 다만, 위에서 언급한 도구들 중 JEB의 경우 디버그 시 에이전트를 사용해 통신하는 방식이 아닌 VM(Virtual Machine) 어태치 방식을 사용하기 때문에 기존의 알려진 방법으로는 탐지가 불가
		JEB에서 디버그 시 참조하는 특정 라이브러리 파일이 사용 중인지 확인한다. 해당 라이브러리 파일이 메모리에 올라와 있다면 애플리케이션이 디버그 모드로 동작 중인 것으로 판단해 탐지
		 TracerPid 값을 확인해 탐지하는 방법이 아닌 별도의 방식을 사용해야 하며 JEB 경우 디버그 시 ART 플러그인 파일인 
		 libopenjdkjvmti 참조한다는 점을 이용해 애플리케이션 메모리 주소에 해당 라이브러리 파일이 올라와 있는지 검증하는 방법으로 탐지
		cat /proc/27442/maps | grep libopenjdkjvmti.so
		
		첫 번째는 File 클래스 생성자를 후킹해 파일 객체 생성 시 들어오는 인자 값이 /proc/self/maps일 경우 더미 값으로 변조하는 방법이고 
		두 번째는 파일이 존재하는 검사일 때 사용하는 exists() 함수의 결괏값을 변조하는 방법이다. 
		마지막 세 번째는 문자열 비교 시 사용한 contains() 함수를 후킹 해 전달되는 인자 값이 libopenjdkjvmti.so일 경우 더미 값으로 변조하는 방법
		
		const fileclass=Java.use("java.io.File");
		const File = fileClass.$init.overload('java.lang.String');
		
		File.implementation=function(path){
			if(path =="/proc/sel/maps"){path="fake"}
			return File.call(this,path);
		}
	
	Bypass Develop Mode
		개발자 옵션에서 디버깅 항목을 보여주고 있으며 이 중 USB 디버깅 설정은 애플리케이션 개발 시 사용되는 Android 스튜디오와 SDK 도구가 USB를 통해 디바이스를 인식할 수 있도록 도와주는 기능
		 isCheckDevelopMode() 함수는 Bypass Develop Mode 탐지 결과를 반환해 주는 역할을 한다. 
		 코드를 보면 Settings 클래스가 사용되었는데 해당 클래스는 디바이스에서 사용하는 설정에 관련된 정보들을 제공해 주며 내부 클래스인 Global를 통해 디바이스에 공통적으로 적용되는 설정값을 참조할 수 있다. 
		 그리고 인자로 전달되는 development_settings_enabled 설정값을 getInt() 함수를 통해 반환받게 된다. 
		 값이 0이면 개발자 옵션이 비활성화 상태를 뜻하고 1이면 활성화 상태
		 
		 첫 번째는 함수 결과와 상관없이 무조건 False를 반환하도록 isCheckDevelopMode() 함수를 재 작성하는 방법이고
		 두 번째는 Settings.Global 클래스 getInt() 함수의 인자로 전달되는 설정값을 변조하는 방법
		
		const settings= Java.use("android.provider.Settiing$Global");
		const getInt = settings.getInt.overload("android.content.ContentResolver", "java.lang.String","int");
		getInt.implementation=function(contest,option,int){
			if(option=="development_settings_enabled"){option="fake"}
			return getInt.call(this,contest,option,int))
		}
		
	Bypass Debugging Mode
		Bypass Debugging Mode 탐지 항목은 개발자 옵션의 USB 디버깅 설정이 활성화되어 있는지 확인
		 isCheckUSBDebuggingMode() 함수는 Bypass Debugging Mode 탐지 결과를 반환해주는 역할을 한다. 
		 코드를 보면 [Bypass Develop Mode] 탐지 파트에서 사용되었던 Settings 클래스가 해당 함수에서도 동일하게 사용
		내부 클래스인 Global을 통해 adb_enabled 설정 값을 참조 후 getInt() 함수를 사용해 값을 가져오고 있다
		
		[Bypass Develop Mode] 탐지 파트에서 언급했던 우회 방법과 동일
		 isCheckDevelopMode() 함수를 재 작성하는 방법이고 두 번째는 Settings.Global 클래스 getInt() 함수의 인수로 전달되는 옵션 값을 변조하는 방법
		 
	Bypass Connect USB
		Bypass Connect USB 탐지 항목은 디바이스에 USB가 연결되었는지 확인하고 연결되어 있다면 애플리케이션이 디버그 모드로 동작 중인 것으로 판단해 탐지하게 된다. 
		하지만, USB 연결의 경우 PC와의 연결을 위해서 사용하기도 하지만 디바이스 배터리 충전 시에도 사용된다. 
		그래서 실제 애플리케이션에서는 USB 연결만으로 디버그 모드가 동작 중이라고 판단하지 않고 추가로 다른 설정들과 함께 참고해 디버그 모드를 탐지
		
		첫 번째는 함수 결과와 상관없이 무조건 False를 반환하도록 isCheckConnectUSB() 함수를 재 작성하는 방법이고 두 번째는
		getBooleanExtra() 함수 호출 시 전달되는 첫 번째 인수 connected를 더미 값으로 변조해 두 번째 인수 값 false를 반환하도록 만드는 방법
		
		const intent= Java.use("android.content.intent");
		const getBool=intent.getBooleanExtra.overload("java.lang.String","boolena");
		
		getBooleanExtra.implementation=function(str,bool){ if(str=="connected") str="fake" 
		return getBooleanExtra.call(this,str,bool)}
		
에뮬레이터
	
	Bypass Build Setting
		에뮬레이터에는 몇 가지 특징이 존재한다. 현재 대다수 출시되고 있는 모바일 디바이스는 ARM 플랫폼의 arm64-v8a(64비트) 아키텍처 기반을 사용한다.
		반면 에뮬레이터의 경우 PC 운영체제와의 호환성을 위해 x86 플랫폼의 32비트 아키텍처 또는 ARM 플랫폼의 armeabi-v7a(32비트) 아키텍처를 사용하는 경우가 많다
		 Build 정보를 확인해 위와 같이 에뮬레이터에서만 발견되는 알려진 특징들이 있을 경우 에뮬레이터 사용자로 판단해 탐지
		Android 7.0 버전의 Nox 에뮬레이터를 사용
		
		 isCheckBuildSet() 함수는 Bypass Build Setting 탐지 결과를 반환해 주는 역할을 한다. 코드를 보면 디바이스의 아키텍처(Architecture) 및 
		 Build 정보를 참조해 에뮬레이터에서 발견되는 특징들이 존재하는지 조건식을 통해 확인하고 있으며,
		 모두 or 논리 함수가 적용된 상태로 조건식 중 하나가 true로 반영될 경우 에뮬레이터 사용자로 탐지
		 
		첫 번째는 함수 결과와 상관없이 무조건 false를 반환하도록 isCheckBuildSet() 함수를 재 작성하는 방법이고
		두 번째는 아키텍처 및 Build 정보를 비교할 때 공통적으로 사용되는 contains() 함수를 후킹 해 매개 변수로 들어오는 비교 문자열을 변조하는 방법
		
		const stringskt=Java.use("kotiln.text.StringsKt__StringsKt");
		const contains1=stringskt.contains.overload("java.lang.CharSequence","char","boolean");
		const contains2=stringskt.contains.overload("java.lang.CharSequence","java.lang.CharSequence","boolean");
		contains1.implementation=function(str1,str2,bool){} ~~ // console.log 로 해당 매개변수 값 출력하여 호출 타입과 디바이스에서 탐지되는 문자열을 확인
		
		이와 같이 출력되는 로그를 통해 클래스 및 함수를 추적하는 기법을 Frida Trace라고 하는데 네이티브 코드 분석 시 자주 사용되는 기법
		contains2 가 i686 으로 출력되고 i686 이 특징이니 해당 contains의 str2를 변경하여 call
		
	
	Bypass Default Files
		에뮬레이터에는 각 제조사 별 프로그램 호환성과 가상 환경 설정을 위한 라이브러리 파일, 명령어 파일 등 전용 설정 파일들이 존재한다.
		예로 국내에서 많이 사용되고 있는 Nox 에뮬레이터의 경우 명령어 파일인 nox-prop, nox-vbox-sf, noxd와 가상환경 공유 라이브러리 파일인 libnoxd.so, libnoxspeedup.so가 있다.
		
		isCheckEmulatorFile() 함수는 Bypass Default Files 탐지 결과를 반환해주는 역할을 한다. 코드를 보면 isFileCheck() 함수를 통해 
		[그림 48]과 같이 리스트로 정의된 genyFiles, andyFiles, noxFiles, pipeFiles 파일 목록이 디바이스에 설치되어 있는지 검사
		
		첫 번째는 함수 결과 상관없이 무조건 false를 반환하도록 isCheckEmulatorFile() 함수를 재 작성하는 방법이고 
		두 번째는 isFileCheck 함수 호출 시 전달되는 인자를 더미 값으로 변조하는 방법이다. 
		마지막 세 번째는 파일 존재의 유무에 대한 결과를 반환 해주는 exists() 함수를 후킹해 반환 값을 변조하는 방법
		
		const emulatordetector = Java.use("com.playground.anditer.EmulatorDector")
		const isfilecheck = emulatordetector.isFileCheck.overload("[Ljava.lang.String");
		let checkList = ["/dev/socket/genyd","/dev/socket/baseband_genyd", ~~] // 해당 부분 검색
		isfilecheck.implementation= function(strlist){
		//filter 각 요소의 조건을 판단할 함수로 true를 반환하면 요소를 유지하고 false를 반환하면 제외합니다.
			const fakelist=strlist.filter((str) => {
				if(checkList.includes(str)){ return false}
				return true // strlist의 요소가 checklist 에 해당하면 false- 즉 제외
			
			})
			return isFileCheck.call(this, fakelist);
		}
	
	Bypass Packages
		Bypass Packages 탐지 항목은 에뮬레이터에 설치되어 있는 전용 마켓 및 관리 애플리케이션의 패키지가 존재하는지 검사하고 존재 시 에뮬레이터 사용자로 판단해 탐지
		
		isCheckEumlatorPackages() 함수는 Bypass Packages 탐지 결과를 반환해 주는 역할을 한다. 코드를 보면 ①에서 에뮬레이터 패키지 목록을 배열 형태로 받아오고 있으며
		②에서 getPackageInfoCompat() 함수를 통해 ①에서 받아온 패키지가 디바이스에 설치되어 있는지 검사
		 getPackageInfo()는 패키지 정보를 가지고 오는 실질적인 함수로써 [그림 54]의 emulatorPackages 리스트 저장되어 있는 데이터를 하나씩 인자 값으로 전달해 패키지 정보를 가지고 온다
		 
		첫 번째는 함수 결과 상관없이 무조건 false를 반환하도록 isCheckEumlatorPackages() 함수를 재 작성하는 방법이고 
		두 번째는 getPackageInfoCompat() 함수로 호출 시 전달되는 인자를 더미 값으로 변조하는 방법
		
		const emulatordetector = Java.use("com.playground.anditer.EmulatorDector")
		const getpackageinfocompat = emulatordetector.getPackageInfoCompat.overload("android.content.pm.PackageManager", 'java.lang.String', 'int')
		
		let packages=["com.google.android.launcher.layouts.genymotion", "com.bluestacks", "com.bignox.app", "com.vphone.launcher", 
		"com.microvirt.tools","com.microvirt.download", "com.cyanogenmod.filemanager","com.mumu.store","com.android.Calendar","com.android.gallery3d"]
		
		getPackageInfoCompat.implementation=function(pm,str,num){
		if(packages.includes(str)){
		 str="fake"}
		 return getPackageInfo.call(this,pm,str,num);
		 }
	
	공격자는 정적 분석을 통해 엔트리 포인트(Entry Point)를 정한 후 동적 분석으로 넘어가 실제 데이터의 흐름과 동작 방식을 분석하는 방법을 선호한다. 
	애플리케이션에서 디버그 사용을 탐지하지 않는다는 것은 이는 공격자의 분석 시간을 줄여주는 것과 같으며 문서에서 언급한 탐지 방안을 포함한 여러 대응 방안을 마련해 디버그 사용을 탐지하고 차단
	
	
프리다
	Bypass File & Path
		에이전트의 경우 실행 시 /data/local/tmp/re.frida.server 디렉터리 내에 Frida에서 사용하는 모듈 및 소켓 파일을 생성
		isCheckFridaBinary() 함수는 ‘Bypass File & Path’ 탐지 결과를 반환해 준다. 코드 상에서 ①은 File 클래스를 사용해 /data/local/tmp 디렉터리 객체를 생성하고
		maxDepath() 함수를 통해 깊이 2만큼의 하위 디렉터리 및 파일 정보를 가지고 온다. ②, ③에서는 ①에서 가지고 온 디렉터리 및 파일 이름에 Frida와 linjector라는 문자열이 포함되어 있는지 검사하고 파일 존재 시 Frida 사용자로 탐지
		
		첫 번째는 함수 결과 상관없이 무조건 false를 반환하도록 isCheckFridaBinary() 함수를 재 작성하는 방법이고, 
		두 번째는 File 클래스 객체 생성 시 전달되는 인자를 더미 값으로 변조하는 방법이다. 
		세 번째는 contains() 함수 사용 시 들어오는 비교 문자열의 매개 변숫값을 변조하는 방법
		
		const fileClass = Java.use("java.io.File");
		const filld= fileClass.$init.overload("java.lang.String");
		
		file.implementation=function(path){
		 if(path=="/data/local/tmp"){path="/data/data"} 
		 return file.call(this,path)}
		 
		권한 설정을 통한 탐지
		Android OS 9.0 이하의 버전에서는 Java API를 이용한 방법을 통해 일부 디렉터리에 권한 부여가 가능했지만, Android OS 10.0 이후 버전부터 도입된 ‘Scoped Mode’도입으로 이 또한 불가능
		/data/local/tmp 디렉터리의 경우 모바일 분석 도구 및 기타 도구 이용 시 사용되는 디렉터리로 일반적으로 일반 사용자에게 읽기 권한이 제한되어 있다. 
		다만, 특정 도구 사용을 위해 해당 디렉터리에 읽기 및 쓰기 권한을 부여해야 할 경우가 생기는데 이 경우 애플리케이션에서 해당 디렉터리에 접근할 수 있게 된다. 
		따라서, 애플리케이션에서 탐지를 위해 디렉터리 정보를 읽어 올 때 일반 사용자 읽기 권한을 제거하면 우회가 가능
		
		chmod 771 /data/local/tmp
	
	Bypass Port
		디폴트 포트인 27042 포트를 사용해 클라이언트와 통신
		isCheckFridaBinary() 함수는 Bypass Port 탐지 결과를 반환해 주는 역할을 한다. 코드를 보면 ①에서 Thread를 생성하고 디바이스 포트 검사를 위해 FridaDetector.isCheckFridaPort..
		inlined.Runnable.1 클래스 객체 정보를 받아오고 있다.
		Socket 클래스를 사용해 디바이스의 27000 ~ 27500 포트 중 연결되어 통신 중인 포트를 검사하고 있으며, isCheckFridaPort() 함수에서 ② Thread.start() 구문 실행 시 run() 함수가 자동으로 호출
		
		첫 번째는 함수 결과와 상관없이 무조건 false를 반환하도록 isCheckFridaPort() 함수를 재 작성하는 방법이고 
		두 번째는 통신 중인 포트를 검사할 때 사용하는 Socket 클래스를 후킹해 생성자 인수 값으로 전달되는 포트 번호를 변조하는 방법
		
		const socketclass=Java.use('java.net.Socket');
		const Socket=socketclass.$init.overload('java.lang.String','int')
		
		Socket.implementation=function(host,port){
			if(port == 27042){
				port = 27000}}
			return Socket.call(this, host,port)
	
		Frida 서버 실행 시 설정할 수 있는 옵션에 관한 설명으로 -h 옵션을 통해 확인할 수 있으며 이 중 –l 옵션의 경우 Frida 서버의 동작 IP 주소 및 포트 지정을 가능
	
	Bypass Module
		 실행중인 애플리케이션 프로세스 정보를 확인하여 매핑되는 Frida 관련 라이브러리가 존재하는지 검사하고 존재할 경우 Frida 서버가 동작 중인 것으로 판단해 탐지
		 
		 isCheckFridaModule() 함수는 Bypass Module 탐지 결과를 반환해 주는 역할을 한다. 코드를 보면 ①에서 프로세스 정보 확인을 위해 /proc/self/maps 파일 객체를 생성하고 있다.
		 /proc/self 디렉터리에는 현재 실행 중인 프로세스에 관한 정보가 저장되어 있으며 maps 파일에서 해당 프로세스의 매핑된 메모리 주소 공간을 확인할 수 있다.
		 ②에서는 maps 데이터를 읽어와 frida 라는 문자열이 포함되어 있는지 검사하며 문자열이 존재할 경우 Frida 사용자로 탐지
		 
		 첫 번째는 함수 결과 상관없이 무조건 false를 반환하도록 isCheckFridaModule() 함수를 재 작성하는 방법이고 
		 두 번째는 File 객체를 읽어올 때 사용된 BufferReader.readLines() 함수를 후킹해 특정 문자열이 포함되어 있을 경우 더미 값으로 변조하는 방법이다.
		 그리고 세 번째는 contains() 함수 호출 시 전달되는 인자 값의 비교 문자열을 변조하는 방법
		 
		 cosnt TextstreamsKt= Java.use('kotllin.io.TextStreamsKt');
		 const readlines=TextstreamsKt.readLines.overload('java.io.Reader');
		 const arraylist=Java.use('java.util.ArrayList')
		 
		 readLines.Java.use("java.util.arraylist");
		 readlines.implementation=function(reader){
			const readlist= readlines.call(this, reader);
			const readline=(readlist).iterator(); //List 타입이기 때문에 interator() 함수를 통해 List에 저장되어 있는 모든 요소 값을 가져온다.
			while(true){
				if(!readline.hasNext()){ break}
				const text= readline.next()
				if(/frida/i.test(text)){
				const fakearray=arraylist.$new()
				fakearray.add('fakevalue')
				return fakearray  //근데 이건 한개만 되는디
				}
			return readlist
	
	
			}
		 }
	
피닝(Pinning)
	피닝은 보편적으로 두 가지 방법을 통해 구현된다. 
	
	첫 번째는 서버와 통신 시 반환되는 인증서가 디바이스의 Root CA에 의해 신뢰할 수 있는 인증서인지 검증하는 방법으로 정상 사용자의 경우 문제가 없으나 패킷 위·변조 목적으로 
	프록시(Proxy) 서버를 경유해 데이터를 주고받는 사용자의 경우 인증서 관련 오류(NET_ERR_CERT_AUTHORITY_INVALID)로 인해 서버와 통신을 하지 못하게 된다.
	두 번째 방법은 클라이언트(디바이스) 단에서 인증서를 고정해 사용하는 방법으로 고정되어 있는 인증서 외의 인증서를 서버가 반환하는 경우 통신을 하지 못하도록 하는 방법이다. 
	이 경우 허용하는 서버의 인증서 값이 애플리케이션 코드 단에 하드 코딩 되어있거나 별도의 방법을 통해 값을 불러와 인증서 값과 비교
	
	Bypass Pinning(Root CA)
		SSL/TLS 인증서는 서버가 클라이언트에게 반환하는 것으로 중간자 공격 시 [그림 34]와 같이 프록시 서버를 거쳐 패킷이 전송되기 때문에 요청한 서버의 인증서가 아닌 
		프록시 서버의 인증서가 클라이언트에게 반환된다. 때문에 디바이스에서는 프록시 서버의 인증서와 Root CA를 비교해 인증서 유효성을 검증하게 되고 등록된 CA의 공개키가 존재하지 않을 경우 신뢰할 수 없는 인증서로 판별
		
		서버에서 반환하는 인증서가 디바이스 Root CA에 의해 신뢰할 수 있는 인증서인지 확인하고 신뢰할 수 없는 인증서인 경우 중간자 공격을 시도 중인 것으로 판단해 탐지
		sCheckRootCA() 함수는 Bypass Pinning(Root CA) 탐지 결과를 반환해 주는 역할을 한다. 코드를 보면 PinningDetector.isCheckRootCA.sendRequestJob.1 클래스가 사용된 것을 볼 수 있으며 코루틴(Coroutine) 관련 로직을 관리하는 클래스
		서버와 통신 작업을 수행하는 invokeSuspend() 함수의 코드이다. 코루틴에서 suspend 함수의 경우 네트워크 관련 비동기 작업 시 사용되는 함수로 호출 시 수행 중이던 작업을 일시 중지하고 suspend 함수 작업이 끝날때 까지 대기하게 된다. 코드를 보면 
		① 서버와의 통신을 위해 OkHttp 라이브러리가 사용되었으며 이때, 서버의 주소를 ④에서 받아와 요청 패킷을 보낸다. 요청에 성공할 경우 ③ onResponse() 함수가 동작하게 되고 요청 실패 시 ② onFailure() 함수가 실행
		
		증서가 신뢰할 수 있는 인증서인지 검증하는 구문이 존재하지 않는다. 그 이유는 인증서 신뢰 유무를 OkHttp 라이브러리에서 확인하기 때문이다. 
		OkHttp의 경우 SSL/TLS 통신 시 내부적으로 HandShake 과정을 거쳐 서버의 인증서가 디바이스에 내장되어 있는 Root CA에 의해 신뢰할 수 있는 인증서인지 검증하게 된다. 
		따라서, 인증서 검증을 우회하기 위해서는 Root CA를 통해 인증서 신뢰 유무 검사 시 사용되는 함수를 후킹해 신뢰할 수 있는 인증서로 변조
		
		trustmanagerImpl 클래스는 Android OS에서 통신을 시도하는 서버가 반환하는 인증서를 Root CA를 통해 인증서 유효성 검증 시 사용되며 이 중 checkTrustedRecursive() 함수에서 인증서 체인을 검증하게 된다. 
		해당 함수의 경우 호출 시 제공된 인증서 체인을 기반으로 Root CA를 통해 신뢰할 수 있는 인증서를 찾아 반환하게 되는데 이때, 빈 리스트를 반환하게 되면 인증서 검증을 수행하지 않고 모든 인증서를 신뢰할 수 있는 것으로 처리한다. 
		따라서, 해당 함수를 후킹해 항상 빈 리스트를 반환하게 만들면 인증서 검증 과정 우회가 가능
		
		Bypass Pinning(Root CA) 탐지 우회를 위해 여기서는 checkTrustedRecursive() 함수를 후킹해 항상 빈 리스트 값을 반환하도록 만들어 우회
		const turstManagerimpl=Java.use('com.android.org.conscrypt.TrustManagerImpl');
		const checkTrustedRecursive = turstManagerimpl.checkTrustedRecursive.overload('[Ljava.security.certX509Certificate;', '[B','[B','java.lang.String','boolean','java.util.ArrayList','java.util.ArrayList','java.util.Set');
		const Arraylist= Java.use('java.util.ArrayList');
		checkTrustedRecursive.implementation=function(arg1,2,3,4,5,6,7,){ return ArrayList.$new();}
		
		Burp Suite 인증서를 디바이스 Root CA에 등록해 탐지를 우회하는 방법도 다뤄보도록 하겠다.
		참고로 해당 방법의 경우 고정 인증서 검증 방식의 피닝 기법이 아닌 Root CA에 의해 신뢰할 수 있는 인증서인지 검증하는 방법에서만 사용해 우회가 가능
		Burp Suite 설정의 ① Tools – Proxy 카테고리에 접근 후 ② import / export CA certificate 버튼을 클릭한다. ③ 인증서 유형은 Certificate in DER format을 선택하고 ④ Next 버튼을 클릭
		① 저장할 인증서의 이름을 지정하고 ② Save 버튼을 클릭
		openssl을 이용해 추출한 인증서 파일(cacert.der)을 .pem 확장자로 인코딩 및 변환
		openssl x509 -inform DER -in cacert.der -out cacert.pem
		openssl을 이용해 변환한 cacert.pem 파일의 해시(Hash)값을 추출하고 cacert.pem 파일의 이름을 추출한 해시값으로 변경하면 인증서 추출 과정이 모두 완료된 것으로 해당 인증서를 디바이스의 Root CA에 추가
		openssl x509 -inform PEM -subject_hash_old -in cacert.pem
		mv cacert.pem 9a5ba575.0
		adb push 9a5ba575.0 /data/local/tmp
		mount -o rw,remount /
		cp /data/local/tmp/9a5ba575.0 /system/etc/security/cacerts/
		mount -o ro.remount /
		기타 보안 설정 – 인증서 확인 항목에서 추가한 인증서를 확인할 수 있으며, Burp Suite 인증서인 PortSwigger CA가 정상 등록된 것을 확인
		
	
	Bypass Pinning(Allow CA)
		고정 인증서 검증 방식으로 애플리케이션에서 허용하는 인증서 외의 인증서를 서버가 반환하는 경우 통신을 하지 못하도록 하는 방법
		 Root CA에 의한 인증서 신뢰 기반의 피닝 기법이 중간자 공격을 막기 위한 가장 기초적인 방어 방법이었다면 고정 인증서 방식은 조금 더 높은 보안을 요구하는 플랫폼에서 사용되는 방법
		 고정 인증서란 디바이스에 임의의 인증서를 설치해 서버와 통신하는 방식이 아닌 애플리케이션의 자바 코드 내에서 특정 호스트와 통신할 때 지정한 인증서의 해시 값과 서버 인증서의 해시 값을 비교해 동일한 해시 값일 경우 통신을 허용하는 방식
		 하드 코딩 방식부터 공격자에 의한 변조 방지를 위한 리소스 다운로드, 동적 로딩 기법 등을 통해 지정
		 
		 Bypass Pinning(Allow CA) 탐지 항목은 통신을 시도하는 서버의 인증서 해시 값이 애플리케이션의 자바 코드에서 지정한 인증서 해시 값과 다를 경우 중간자 공격을 시도 중인 것으로 판단해 탐지
		  isCheckAllowCA() 함수는 Bypass Pinning(Allow CA) 탐지 결과를 반환해 주는 역할을 한다. 코드를 보면 ①에서 OkHttp.certificatePinner 
		  클래스 객체를 생성할 때 호스트 이름과 서버의 인증서 해시 값을 인자로 넘겨주고 있으며 해당 해시 값이 서버와 통신 시 인증서 비교에 사용되는 값
		  sha256/+hIxKEB6NLsH9zGi9fx81iY3nbFfuipoNjz1liP ufEI=“와 비교해 다를 경우 통신을 하지 못하게 한다
		코루틴의 suspend() 함수이다. ① [그림 50]의 isCheckAllowCA() 함수에서 생성한 OkHttp.certificatePinner 클래스 객체를 통해 통신을 수행하게 되며 ② 통신 성공 시 onResponse() 함수가 동작되며 ③ 통신 실패 시 onFailure() 함수가 실행
		check$okhttp() 함수는 클라이언트와 서버가 SSL/TLS HandShake를 진행할 때 인증서의 유효성 검사 시 사용되는 함수
		findMatchingPins() 함수의 경우 호스트 이름과 매핑되는 인증서의 핀 리스트를 반환하는 역할을 수행하는 데 호스트 이름과 일치하는 고정된 인증서가 존재하지 않을 경우 빈 리스트를 반환
		 빈 리스트라면 check$okhttp() 함수는 인증서에 대한 유효성 검사를 수행하지 않고 null 값을 반환하게 되며 이는 고정 인증서 핀을 우회하고 어떤 인증서든 사용할 수 있게 허용
		 
		첫 번째는 인증서의 유효성 검사를 수행하지 않게 항상 null 값을 반환하도록 check$okhttp() 함수를 재 작성하는 방법이고 
		두 번째는 호스트 이름에 매핑되는 인증서를 찾을 때 사용하는 findMatchingPins() 함수의 결괏값을 매핑되는 인증서가 없을 때와 동일하게 항상 빈 리스트를 반환하도록 변조하는 방법
		
		const CertificatePinner=Java.use("okttp3.CertificatePinner");
		const check$okhttp = CertificatePinner.check$okhttp.overload("java.lang.String", "kotlin.jvm.functions.Function0");
		check$okhttp.implementation=function(arg1,arg2){
		return}
	
	프리다는 모바일 애플리케이션의 보안을 위협하는 공격자에게 있어서는 필수적인 도구로 이론적으로 애플리케이션 단에서 동작하는 모든 네이티브 코드에 한해서 변조 및 우회가 가능하다. 실제로 잘 만들어진 프리다 스크립트는 대 다수의 보안 탐지 코드를 무력화 시킬 수 있기에 반드시 사전에 프리다 도구를 탐지해 차단 하는 조치가 이뤄져야 하고 문서에서 기술한 탐지 방안 외에도 최근 보안 솔루션에서 많이 적용되고 있는 역 후킹 기법 등을 도입해 애플리케이션에서 발생할 수 있는 보안 위협을 방어해야 한다.



	애플리케이션 보안 위협은 네이티브 코드 단에서만 발생하는게 아니다. 루팅, 디버그, 프리다 등이 애플리케이션 내에 동작하는 코드 위·변조를 막기 위한 조치 단계였다면 
	이후는 피닝을 통해 애플리케이션이 API 서버와 통신하며 받아오는 데이터 노출을 최소화하고
	 이에 따른 데이터 위·변조를 막기 위한 단계이다. 일례로 2017년 여기어때에서 SQL Injection 공격을 통해 개인정보 99만건이 유출된 사건도 있다.
	 물론, SQL Injection, XSS, File Upload, File Download 등의 웹 기반 공격은 백엔드(Back-End) 단의 탐지 로직이 중요하다
	. 하지만, 그 전에 이러한 웹 기반 공격을 가능케 하는 것이 바로 중간자 공격이다. 
	따라서, 중간자 공격을 막는다는 것은 애플리케이션과 통신하는 서버 단에서 발생할 수 있는 보안 위협을 방어하는 것과 같은 이치라고 할 수 있다.
	 문서에서 기술한 피닝 기법 외에도 별도로 인증서가 신뢰할 수 있는 인증서인지 검증하는 코드 추가가 필요하며 서버 단에서는 종단간 암호화 적용을 고려



무결성(Integrity)
	코드 무결성을 검증하기 위한 대표적인 방법에는 구글에서 제공하는 ‘Play Integrity API’를 사용하는 방법, CRC(Cyclic Redundancy Check) 체크섬 검증, 개발자 사이닝 키(Developer Sinning Key) Hash 값 검증, 리소스 파일 검증 등이 있다.
	
	
	Bypass App Name
		크래커들은 앱 이름, 이미지, 레이아웃 등 애플리케이션의 리소스 파일을 수정하는 경우에는 변조된 앱이라는 것을 식별하기 위해 앱 이름에 ‘Mod’라는 키워드를 붙이거나, 제작자의 이름 추가 및 앱 아이콘을 제작자의 시그니처 아이콘 이미지 등으로 교체
		
		AndroidManifest.xml 파일에서 [그림 6]과 같이 <application>태그 → android-label 속성을 통해 앱 이름을 확인할 수 있다.
		다만, [그림 6]을 보면 앱 이름이 'ANDITER'가 아닌 '@string/app_name'으로 명시되어 있는데 이는 안드로이드에서 사용되는 리소스 참조 구문으로 리소스 파일 중 strings.xml 파일에 정의되어 있는 app_name 요소 값을 호출하겠다는 의미
		strings.xml이 위치한 경로는 디컴파일의 산출물 결과 기준으로 [그림 7]과 같이 smali → values → string.xml에서 확인이 가능
		변경하고자 하는 값인 “FAKEANDITER”로 수정
		 
		isCheckAppName() 함수는 Bypass App Name 탐지 결과를 반환하는 역할을 한다. 코드를 보면 IntegrityDetector 클래스의 생성자를 통해 생성된 
		인스턴스 this.appName 변숫값을 areEqual() 함수를 통해 “ANDITER”문자열과 동일한지 검사
		
		① 함수 결과와 상관없이 호출 시 무조건 False 값을 반환하도록 isCheckAppName() 함수를 재 작성하는 방법
		② Intrinsics.areEqual() 함수를 후킹 해 함수 호출 시 전달되는 인자 값 “ANDITER”를 변조한 앱 이름과 동일하게 맞춰주는 방법
		③ IntegrityDetector 생성자를 통해 생성되는 인스턴스 this.appName 변숫값을 변조한 앱 이름으로 변경하는 방법
		
		Java.choose("com.playground.anditer.IntegrityDetector",{
		onMatch:function(mContext){
			mContext.appName.value="faketer"
			
		},
		onComplete:function(){}
		})
		Java.choose 함수, 함수의 경우 힙(Heap) 메모리에서 인스턴스를 찾을 때 사용되며, ② onMatch 구문을 통해 찾고자 하는 인스턴스를 호출하고 인자로 전달된 변숫값을 통해 인스턴스에 접근
		
	Bypass Hash Key
		APK(Android Package)로 컴파일 될 때 개발자가 지정한 서명키로 앱이 서명된다. 
		안드로이드의 OS 보안 정책상 서명키가 존재하지 않는 애플리케이션은 디바이스에 설치가 제한되기 때문에 모든 앱은 각자 고유한 서명키를 가지게 된다
		. 서명키는 일반적으로 보안 해시 알고리즘인 SHA(Secure Hash Algorithm)를 사용하기 때문에 개발자가 생성한 키값을 모르면 해시 다이제스트(Hash Digest)를 크래킹 할 수 없다
		APK Easy Tool도 컴파일 과정이 끝난 후 마지막 단계에서 자동으로 앱을 서명하는데, 
		[그림 14]와 같이 sign –key 구문의 apkeasytool.pk8과 apkeasytool.pem이 바로 서명과 인증 정보를 등록하기 위한 KeyStore 파일들로 APK Easy Tool에서 임시로 생성한 서명 키값이 들어가게 된다
		
		 isChckHashKey() 함수는 Bypass Hash Key 탐지 결과를 반환 해주는 역할을 한다. 코드를 보면 ①에서 안드로이드 OS 버전에 따른 코드 분기를 나누고 있으며, 코드에 명시된 SDK 28 버전은 안드로이드 9버전을 뜻한다. 
		 ②에서는 getPackageInfoCompat(),getApkContentsSigners() 함수를 통해 ANDITER(com.playground.anditer)의 패키지 정보에서 서명 정보를 가져온다. 
		 ③에서는 가져온 서명 정보를 Base64로 인 코드(encode) 후 ④ areEqual() 함수를 통해 “7nd5QagBehUoHzVC+c43zic+/ro=” 값과 동일한지 검사
		 
		① 함수 결과와 상관없이 호출 시 무조건 False 값을 반환하도록 isCheckHashKey() 함수를 재 작성하는 방법
		②서명 정보를 Base 64로 인코딩 하기 위해 사용한 encodeToString() 함수를 후킹해 [그림 16]의 ④에서 서명 정보 비교 시 사용된 “7nd5QagBehUoHzVC+c43zic+/ro=” 값을 반환하도록 변조하는 방법
		③areEqual() 함수를 후킹해 서명 정보 비교를 위해 두 번째 인자로 전달되는 값이 “7nd5QagBehUoHzVC+c43zic+/ro=”일 경우 true를 반환하도록 변조하는 방법
		
		const base64=Java.use("android.util.Base64");
		const encodetoString=Base64.encodeToString.overload("[B","int")
		
		encodeToString.implementation=function(list_b,int){
		retunr "7nd5QagBehUoHzVC+c43zic+/ro="}
		
		
		** mt manger
		
		MT Manager는 안드로이드 OS의 파일 관리자 및 APK 편집 기능을 가진 애플리케이션으로 디바이스에 설치된 앱을 관리하고, 코드 수정, 텍스트 편집 등의 작업을 수행하는 데 사용되는 강력한 도구이다. 
		관리자 권한(root)을 부여받지 못할 경우에는 일반적인 파일 관리자 앱과 차이가 없지만, 관리자 권한이 부여될 경우에는 
		시스템 디렉터리 액세스, 파일 시스템 마운트, 권한 변경 등의 작업과 dex, arsc, xml 파일 편집, APK 서명 및 서명 확인 제거 등의 매우 강력한 기능을 사용할 수 있게 된다.
		
		대표 APK 공유 사이트로 아래의 두 곳이 존재하며, APK Combo(https://apkcombo.com/ko/mt-manager/bin.mt.plus/)에서 MT Manager 다운로드가 가능하다.
		① APK Combo(https://apkcombo.com/ko/)
		② APK Pure(https://apkpure.com/kr/)
		
		변조되지 않은 ANDITER를 다시 설치한다. ① 그 후 [그림 21]과 같이 ANDITER 앱의 실행 파일인 base.apk 파일이 위치한 곳으로 이동 후 해당 파일을 클릭한다. 
		② 그 후 출력되는 알림 창에서 VIEW 버튼을 클릭
		ANDITER의 내부 파일 중에서 실행 코드가 담긴 classes.dex 파일을 클릭하고 ② Dex 편집기 기능에서 "Dex Editor plus"를 선택해 준다. 
		③ ANDITER의 경우 MultiDex로 구성되어 있기 때문에 Dex 파일이 총 두 개의 파일로 분할되는데 모두 선택해 OK 버튼을 클릭
		① Bypass App Name 탐지 항목의 검사 코드를 가지고 있는 IntegrityDetector 클래스의 smali 코드가 위치한 곳으로 이동한다. [ com → playground → anditer → IntegrityDetector ]
		② 그리고 해당 smali 파일의 80번 라인에 위치한 앱 이름인 ANDITER를 변경하고자 하는 이름으로 변경해 준다. 여기서는 "FAKEANDITER"로 변경
		코드를 변경했다면 디바이스에서 뒤로 가기 버튼을 클릭해 편집기에서 빠져나온 후 ① [그림 24]와 같이 상단의 망치 버튼을 클릭해 변경한 Dex 파일을 컴파일 해준다. 
		② 그리고 다시 디바이스에서 뒤로 가기 버튼을 클릭하면 Dex 편집기로 진입하기 전의 화면으로 되돌아가며 [그림 24]의 오른쪽 화면과 같이 알림 창이 출력된다.
		여기서 "AUTO SIGN"을 체크해 주고 "OK" 버튼을 클릭하면 최종적으로 MT Manager를 이용한 변조 과정이 끝난다.
		
		존의 변조한 코드를 컴파일 하고 APK 파일을 재 설치해 앱을 동작시키는 방식이 아닌 라이브(Live) 상태에서 코드를 변조하기 때문으로 변조된 APK 파일을 재 설치하지 않는 이상 
		[그림 26]과 같이 서명 키를 제거해도 Java 코드 단에서는 서명 키가 변조된 것을 탐지하지 못한다. 이와 같은 라이브 상태에서 수행하는 코드 변조 방법을 무서명 변조 기법이라고 부르며, 
		Dex와 같은 실행 코드가 담긴 파일은 변경 이력이 바로 적용되지만 서명 키는 적용되지 않는 점을 이용한 변조 방법이다.
		따라서, 앱에서 서명 키를 검사해 무결성 변조를 탐지하고 있다면 APK Easy Tool과 같은 디컴파일 도구를 사용하는 것보다 MT Manager와 같은 애플리케이션을 사용하는 것이 훨씬 더 효율적
		
		이를 대응하기 위한 방안에는 Dex 파일 체크섬 검증과 구글 Play 서명 검증 그리고 디바이스에 MT Manager와 같은 앱이 설치되었는지 확인하는 방법이 있다.
		

	Bypass Installer
		설치된 앱의 패키지 관리(Package Management) 정보에는 앱을 다운로드했던 출처 정보(Installer Source Information)가 기록되어 있어 [그림 28]과 같이 pm(Package Manager) 명령어로 확인
		pm list packages -i com.playground.anditer
		installer 속성을 보면 다양한 출처 정보를 확인할 수 있는데, 대표적으로 구글의 Play Store는 “com.android.vending”, “com.google.android.packageinstaller”를 사용하고 삼성의 갤럭시 스토어는 패키지 정보에 “samsung”이라는 문자가 포함되어 있다.
		반면 비공식 스토어로 다운로드한 앱의 경우에는 [그림 29]와 같이 "null(출처 불명)"로 표시된다. 다만, 공식 스토어를 통해 다운로드한 앱의 경우에도 변조하는 경우에는 리패키징 과정을 통해 출처 정보가 초기화되기 때문에 출처 정보가 “null”로 표기
		
		isCheckInstaller() 함수는 Bypass Installer 탐지 결과를 반환해 주는 역할을 한다. 
		코드를 보면 ① IntegrityDetector 클래스의 생성자를 통해 통해 출처 정보가 담긴 인스턴스 installStore 변수가 생성되고 ② ANDITER의 패키지 정보(com.playground.anditer)에서 출처 정보 비교 시 사용되는 것을 볼 수 있다.
		이때, 가져온 출처 정보가 installStore에 저장된 값과 다를 경우 앱이 변조된 것으로 판단해 탐지
		 
		① 함수 결과와 상관없이 호출 시 무조건 False 값을 반환하도록 isCheckInstaller() 함수를 재 작성하는 방법
		② IntegrityDetector 생성자를 통해 생성되는 인스턴스 변수인 installStore 값을 변조하는 방법
		③ 문자열 비교 시 사용되는 areEqual() 함수를 후킹 해 함수로 들어오는 매개변수 값이 installStore 변수에 정의된 패키지 이름과 같을 경우 True를 반환하도록 하는 방법
		
		const intrinsics = Java.use("kotlin.jvm.internal.Intrinsics");
		const areEqual = intrinsics.areEqual.overload("java.lang.Object","java.lang.Object")
		
		let sourceInfo=["com.android.vending", ~~]// 체크하는 정상 패키지
		areEqual.implementation=function(obj,obj2){
			const packageName = String(obj)
			if(sourceInfo.includes(packageName){
			return true}) // 패키지 비교하는경우만
			return areEqual.call(this,obj,obj2)
			
		}
		
		
		**Package Manager 명령어를 이용해 APK 파일 설치 시 출처 정보를 삽입하여 탐지를 우회하는 방법
		“list packages” 명령어를 통해 패키지 관련 정보 참조가 가능하며 "-i" 옵션과 조합해 출처 정보를 확인
		공식 루트를 통해 다운로드해 설치한 것이 아니므로, 출처 정보가 “null”로 표기
		ADB를 통해 앱을 설치할 때  기존의 설치 명령어에서 "–i" 옵션만 추가
		adb install -i "com.android.vending" "Anditer(noencryption).apk"
		
	
	Bypass CRC
		공격자가 앱을 변조하기 위해서는 “classes.dex”파일을 디컴파일한 산출물인 smali 파일이 수정돼야 한다는 점을 착안한 무결성 검증 방법
		
		isCheckCRC() 함수는 Bypass CRC 탐지 결과를 반환해 주는 역할을 한다. 
		코드를 보면 ① ZipFile 클래스를 통해 현재 애플리케이션의 압축된 APK 파일을 열람하고 ②에서 “classes.dex” 파일의 엔트리 정보를 가져와
		getCrc() 함수를 통해 CRC 값을 추출한다. ③ 추출한 CRC 값을 미리 정의된 CRC 체크 코드와 비교해 값이 다를 경우 앱이 변조된 것으로 판단해 탐지
		
		① 함수 결과와 상관없이 호출 시 무조건 False 값을 반환하도록 isCheckCRC() 함수를 재 작성하는 방법
		② areEqual() 함수를 이용해 CRC 값 비교 시 전달되는 인자 값을 변조하는 방법
		③ ZipFile 클래스를 통해 압축된 APK 파일 열람을 시도할 때 전달되는 APK 파일이 위치한 경로 인자 값을 변조해 사용자가 임의 지정한 파일을 열람할 수 있도록 변조하는 방법
		
		먼저 변조되지 않은 ANDITER APK 파일을 [그림 42]와 같이 ADB 명령어를 사용해 디바이스 내 “/data/local/tmp” 경로로 이동
		① ADB 원격 셸로 접근 후 ② su 명령어를 사용해 관리자 권한을 획득하고 ③ “/data/local/tmp” 디렉터리에 일반 사용자 읽기 및 쓰기 권한을 부여
		(앱 코드 단에서 “/data/local/tmp” 디렉터리에 위치한 원본 APK 파일에 접근할 수 있도록 해주기 위함)
		
		const zipfileclass=Java.use("java.util.zip.ZipFile");
		const zipfile=zipfileclass.$init.overload("java.langString")
		
		zipfile.implementation=function(path){
			if(/com.playground.anditer/gi.test(path)){//ipFile 클래스 생성자 호출 시 전달되는 인자 값인 파일이 위치한 경로에 “com.playground.anditer” 문자열이 포함되어 있을 경우
			const fakepath="/data/local/tmp/Anditer(NoEncryption).apk"} 
			return zipfile.call(this,fakepath)
			}
			return zipfile.call(this.path)		
		}
		
		
		
동적 로딩(Dynamic Dex Loading) 
	코드 노출 최소화의 기본은 코드의 식별성을 저해하는 난독화를 목적으로 하며, 정적인 형태가 아닌 동적인 형태로 코드를 호출해서 코드의 식별성을 저하시키는 기법을 동적 난독화
	
	동적 로딩(Dynamic Dex Loading) 기법은 안드로이드 애플리케이션에서 Dex 파일을 동적으로 로드해서 실행하는 기법이다. 
	개발자 입장에서는 새로운 기능 추가 및 업데이트 시에 모듈화를 통해 동적으로 로드하게 되면 앱 유지보수와 확장성, 보안성을 향상시킬 수 있다.
	기존에는 동적 로딩이 유지보수와 편의성을 목적으로 사용되었다면, 최근에는 Dex 파일을 동적 로딩하여 공격자가 공격코드를 숨기거나 보안 솔루션이 탐지코드를 숨기는 용도로 사용
	dexdir=mContext.codeCacheDir
	DexClassLoader(dexFile...)
	dexClassLoader.loadClass(...)
	loadClass.newInstance()
	loadClass.getMethod("")z
	...
	
	동적 로딩 구현을 위해 사용되는 대표적인 자바 클래스로는 ClassLoader, Reflection이 있으며, 안드로이드에서 외부 Dex 파일을 로드하는 데 사용되는 
	클래스의 종류로는 DexClassLoader, PathClassLoader, BaseDexClassLoader가 있다. 이 중 Dex 파일을 로드하는데 일반적으로 사용되는 대표적인 클래스는 DexClassLoader
	
	DexClassLoader는 Dex 파일뿐만 아니라 이미지, 텍스트, 레이아웃 등과 같은 리스소 파일도 로드가 가능하다. 
	그리고 이렇게 로드되는 파일은 일반적으로 앱 패키지 내 “assets” 디렉터리에 저장되어 있으며, 앱 실행 중 필요시 DexClasssLoader를 호출해 “assets” 디렉터리에 존재하는 리소스 및 Dex 파일을 메모리에 로드
	
	“assets” 디렉터리에 “dynamic” 이라는 Dex 파일이 존재
	보안 솔루션과 악성 앱에서 DexClassLoader를 이용한 동적 로딩 기법을 구현할 때에는 
	[그림 47]과 같이 파일을 미리 생성해 “assets” 디렉터리에 넣어두는 방식이 아닌 별도의 모듈을 사용해서 암호화된 코드를 복호화 해 앱 실행 중에 생성될 수 있도록 한다.
	그렇다고 동적 로딩 기법을 사용하는 모든 앱이 그런 것은 아니므로, 분석 시 “assets” 디렉터리가 존재할 경우 확인해 봐야 한다.
	
	“assets” 디렉터리는 앱 패키지 내부에만 존재하고 있어 실제로 앱을 설치해서 확인해 보면 디바이스의 파일 시스템에 해당 디렉터리가 생성되어 있지 않는 것을 알 수 있다.
	이는 Android OS 보안 정책에 의한 것으로 앱이 설치될 때 APK에서 파일을 추출하여 앱 내부에서만 접근할 수 있게 되어 있다. 
	[그림 48]은 “assets” 디렉터리에 위치한 파일의 추출 과정을 보여주는 것으로 앱 실행 시 “assets”에서 파일(Dex, 리소스 등)을 읽어 들여 내용을 복사하고 새로운 파일을 생성해서 복사한 내용을 붙여 넣는다.
	그 후 앱의 캐시 파일 및 임시 파일을 저장하는 개인 데이터 영역인 “cache” 디렉터리에 파일을 저장하고 필요시 메모리에 로드하여 사용
	앱의 개인 데이터 영역인 “code_cache” 디렉터리에 읽어 들인 “assets” 파일이 저장되어 있는 것을 알 수 있다
	
	isCheckDynamic() 함수는 Bypass Dynamic Code 탐지 결과를 반환해 주는 역할
	
	Bypass Dynamic Code
		Bypass Dynamic Code 탐지 항목은 동적 로딩 기법을 이용해 외부 Dex 파일의 클래스와 함수에 의해 해당 항목에 무조건 탐지되도록 설정되어 있다.
		따라서, 외부 Dex 파일을 분석해 탐지가 되지 않도록 우회
		
		public final boolean isCheckDynamic(boolean z) {
        File file0 = this.mContext.getCodeCacheDir();
        File file1 = new File(file0.getAbsolutePath(), "dynamic");
		//외부 Dex 파일을 읽어 들인 후 파일의 내용을 새로운 파일에 저장하기 위해 File 클래스 생성자를 호출하여 “dynamic” 이름을 가진 파일 객체를 생성
		
        boolean z1 = false;
        try {
            BufferedInputStream bufferedInputStream0 = new BufferedInputStream(this.mContext.getResources().getAssets().open("dynamic"));
			//getAssets().open() 함수를 통해 “assets” 디렉터리에 위치한 “dynamic” Dex 파일의 코드를 읽어와 
			
            BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(new FileOutputStream(file1));
            byte[] arr_b = new byte[0x400];
            while(true) {
            label_6:
                int v = bufferedInputStream0.read(arr_b);
                if(v > 0) {
                    bufferedOutputStream0.write(arr_b, 0, v);
                    goto label_6;
                }
				//①에서 생성한 “dynamic” 파일 객체에 해당 코드를 저장
				
                bufferedOutputStream0.close();
                bufferedInputStream0.close();
                Class class0 = new DexClassLoader(file1.getAbsolutePath(), file0.getAbsolutePath(), null, this.mContext.getClassLoader()).loadClass("com.playground.anditer.Dynamic");
				//③에서 저장한 Dex 파일의 경로를 인자 값으로 사용하여 DexClassLoader 생성자를 호출하고 객체를 생성
                Object object0 = class0.newInstance();
                Object object1 = class0.getMethod("getResult").invoke(object0);
				// 생성된 인스턴스를 통해 getResult() 함수를 호출하여 탐지 결괏값을 반환
                Intrinsics.checkNotNull(object1, "null cannot be cast to non-null type kotlin.Boolean");
                z1 = ((Boolean)object1).booleanValue();
                if(z) {
                    this.deleteFile(file1);
                    return z1;
                }

                return z1;
            }
        }
        catch(Exception exception0) {
            exception0.printStackTrace();
        }

        return z1;
		}
	
		DexClassLoader에서 호출되는 함수를 우회하기 위한 원본 Dex 파일을 찾아야 한다. 이를 위해 다음 2가지 접근 방식을 살펴볼 것이다.
		① DexClassLoader 클래스 생성자를 후킹하여 생성자 호출 시 전달되는 인자 값(파일이 위치한 경로)을 확인하는 방법
		② 메모리 매핑 정보를 제공하는 가상 파일에서 흔적을 찾는 방법
		
		DexClassLoader 생성자를 후킹하기 위한 기능을 담고 있다.
		①에서는 DexClassLoader 클래스를 사용하기 위한 참조를 얻고 ②에서는 isCheckDynamic 생성자 호출 시 전달되는 인자 값 중에 파일의 절대 경로를 가지고 있는 첫 번째 인자 값을 로그로 출력
			const dexclassloader = Java.use("dalvik.system.DexClassLoader")
			const DexclassLoader = dexclassloader.$init
			
			DexclassLoader.implementation=function(filepath, dirpath, nul, loadpath){
				console.log("dex file path -> ", filepath);
				return DexClassLoader.call(this,filepath,dirpath, nul, loadpath);
			}
		로드되는 Dex 파일이 위치한 절대 경로,  Frida 스크립트를 실행하면 앱에서 Dex 파일 로드 시 [그림 53]과 같이 Dex 파일이 저장된 절대 경로를 알 수 있다.
		
		
		
		앱의 메모리 매핑 정보를 활용하여 동적 로딩의 흔적을 찾아보는 방법
			ps -ef | grep "com.playground.anditer" -> pid 확인
			cat /proc/9375/maps | grep "com.playground.anditer" -> 메모리 매핑정보 파일 정보 출력
				/data/data/com.playground.anditer/code_cache/dynamic” 파일이 참조되어 있는 것을 확인
				DexClassLoader 클래스가 외부 Dex 파일을 참조할 때 메모리에 로드하는 특성 때문으로 삭제된 파일의 흔적 확인
				
			추출하기
			cp /data/data/com.playground.anditer/code_cache/dynamic /data/local/tmp
			chmod 777 /data/data/com.playground.anditer/code_cache/dynamic
			adb pull /data/local/tmp/dynamic
		
			추출한 Dex 파일을 JEB 디컴파일러를 사용하여 나타낸 복호화 한 코드로 하나의 클래스(Dynamic)와 멤버 함수(getResult)로 구성
			getResult() 함수는 [그림 51]에서 ClassDexLoader의 인스턴스 객체를 통해 호출된 함수로 호출 시 true를 반환하여 Bypass Dynamic Code 항목에 탐지되도록 만든다.
			
		“com.playground.anditer” 로 “Dynamic” 클래스를 참조할 경우 [그림 58]과 같이 경로 참조 실패에 관한 오류가 발생
		Frida는 앱이 실행되고 타깃 앱이 ART 런타임에서 동작할 때 런타임에 로드되는 메모리 정보에서 클래스와 함수 정보를 가져와 후킹 작업을 수행하는 데 
		동적 로딩을 통해 로드한 Dex 파일은 ART에서 가져온 정보가 아니기에 Frida가 해당 영역에 직접 접근 불가
		별도의 Dex 파일 로더를 구현하여 Dex 파일을 메모리에 로드 한 후, 해당 영역에 포함된 클래스 정보를 참조해야 한다.
		
		const DexClassLoader==Java.use("dalvik.system.DexClassLoader");
		DexClassLoader.$init.implementation=function(filepath, dirpath, nul, loadpath){
			console.log("dex file path", filepath)
			this.$init(filepath, dirpath, nul, loadpath) 
			// 생성자 호출 시 전달되는 인자 값을 사용하여 새로운 DexClassLoader 객체를 생성한다. 생성된 DexClassLoader 객체는 hookloadedfunctions() 함수의 인자로 전달
			hookloadedfunctions(this)
		}
		function hookloadedfunctions(dexclassloader){
			Java.classFactory.loader=dexclassloader
			//Java.classFactory.loader에 해당 객체를 할당함으로써 외부 Dex 파일의 클래스 및 함수를 참조할 수 있게 된다. 
			
			const target_class="com.playground.anditer.Dynamic"
			const class_refer=Java.use(target_class)
			const getResult = class_refer.getResult
			// Dex 파일의 정보를 토대로 Dynamic 클래스를 참조하기 위한 변수를 지정
			
			getResult.implementation=function(){ //  getResult 함수를 재정의하여 false 값을 반환
				return false
			}
			
		}
	
	Bypass Hide Code
		Bypass Dynamic Code 항목과 동일하게 DexClassLoader를 사용하여 외부 Dex 파일을 가져온다. 
		다만, Bypass Hide Code는 Bypass Dynamic Code 항목과 달리 Dex 파일을 불러오고 파일을 삭제한다는 점에서 차이
		
		본 코드 아래 삭제부분, 매개ㄱ변수에 z에따라 삭제
		z1 = ((Boolean)object1).booleanValue();
		if(z) {
			this.deleteFile(file1);
			return z1;
		}
		인자로 전달된 파일 객체를 참조해 파일이 존재할 경우 해당 파일을 삭제
		/data/data/com.playground.anditer/code_cache/dynamic 해당 파일 삭제됨
		
		매핑 정보에는 (deleted) 라고 삭제된 정보가 남아있음 -> 삭제되도 dex 파일 확인이 가능함
		
		원본 Dex 파일을 확보하는 것이 매우 중요하다. 삭제된 파일을 복구하기 위해서는 일반적으로 2가지 방법이 사용된다. 
		첫 번째는 파일 삭제 작업을 수행하는 함수를 후킹하여 파일이 삭제되는 것을 막는 방법이며, 
		두 번째는 메모리에 로드된 Dex 파일을 덤프(dump)하여 원본 파일을 복구하는 방
		
		파일 삭제 작업을 수행하는 함수를 후킹
		const file =Java.use("java.io.File")
		File.delete.implementation=function(){
			console.log(" 파일 삭제 -> ", this.getPath.call(this))
			return false
		}
		
		실제 애플리케이션에서 해당 방법을 통해 얻은 Dex 파일들은 대부분 암호화되어 있어 별도의 복호화 함수와 키 값을 찾아야 함.
		Dex 파일이 암호화되어 있더라도 메모리에 로드될 때에는 복호화 된 코드가 적재되므로, 메모리 덤프 방법은 파일 삭제를 방지하는 방법보다 더욱 용이하게 Dex 파일을 복구
		강화된 보호 메커니즘을 사용하는 앱의 경우에는 메모리에도 암호화된 상태로 저장될 수 있으므로, 복호화를 위한 함수와 키값의 정보를 찾아야 한다
		
		pip install frida-dexdump
		메모리에 적재된 Dex 파일을 추출하기 위해서는 앱의 메모리를 덤프하고, 덤프 된 파일 중에서 Dex 시그니처를 가진 파일을 선별하여 확인해야 한다. 
		하지만, Frida-DexDump 도구를 사용하면 이러한 선별 과정들을 생략하고 Dex 파일만을 쉽게 추출
		frida-dexdump -U --sleep 10 -f com.playground.anditer
		, -f 옵션은 스폰(Spawn), –F 옵션은 어태치 (attache) 방식으로 동작
		Bypass Hide Code 항목을 체크하기 전까지 메모리 덤프를 하지 않도록 –-sleep 옵션을 추가
		명령어를 실행한 다음에 Bypass Hide Code 항목을 체크하고 잠시 기다리면, [그림 70]과 같이 메모리 덤프가 자동으로 시작
		덤프 된 파일은 앱 패키지 이름(com.playground.anditer)을 가진 디렉터리에 저장되며, 이 디렉터리에는 외부 Dex 파일뿐만 아니라 메모리에 적재된 모든 Dex 파일이 함께 저장
		대부분의 동적으로 로드되는 Dex 파일은 코드가 짧기 때문에 용량이 가장 작은 파일부터 확인하는 것이 용이
		
		추출후 위와 동일하게 우회(getResult.implementation 하여)
		
		
		
네이티브 코드(Native Code) 
	네이티브 코드는 안드로이드 애플리케이션에서 C/C++ 언어로 작성된 코드를 말한다. 
	안드로이드 애플리케이션은 주로 Java와 Kotlin 같은 고수준 프로그래밍 언어로 개발되지만, 일부 기능이나 성능 향상, 하드웨어 접근, 호환성을 이유로 네이티브 코드를 활용
	
	네이티브 코드는 하나의 라이브러리 파일(.so)로 구성되며, 앱에서 이를 사용하고자 하는 경우 System.loadLibrary() 함수를 통해 라이브러리 파일을 로드하여 사용
		ㆍarm64-v8a : 64비트 ARM 아키텍처
		ㆍarmeabi-v7a : 32비트 ARM 아키텍처
		ㆍx86 : 인텔(Intel) 및 AMD의 32비트 x86 프로세서 아키텍처
		ㆍx86_64 : 인텔(Intel) 및 AMD의 64비트 x86 프로세서 아키텍처
		getprop ro.product.cpu.abi
	
	
	Bypass Native(Rooting-Files)
		isCheckRooted() 함수는 Bypass Native(Rooting-Files) 탐지 결과를 반환해주는 역할
		네이티브 코드로 작성된 함수들은“native”라는 함수 수식어를 가지며, 이를 통해 해당 함수가 네이티브로 코드로 작성된 함수임을 알 수 있다
		System.loadLibrary() 구문을 통해 어떤 라이브러리 파일이 로드되었는지 알 수 있다. 또한, 
		해당 구문을 통해 라이브러리 파일 로드 시 파일 확장자(.so)와 파일 이름 앞의 “lib“를 생략하여 호출하기에 “anditer”가 아닌 “libanditer.so” 파일이 호출
		 JEB를 통해 추출하거나 또는 대상 앱을 압축 해제하여 “lib” 디렉터리에 위치한 라이브러리 파일을 가져옴
		 
		C/C++ 라이브러리 파일을 분석하기 위해서는 IDA, Ghidra, RetDec, Snowman 등과 같은 전용 디컴파일러 도구를 사용
		첫 번째가 Java 코드와 네이티브 코드 간의 연동을 위해 사용되는 JNI(Java Native Interface) 함수명 규칙으로 “Java_[피키지 이름][클래스][함수명]”와 같은 형식을 가짐
		다음으로 두 번째는 Java 코드에서 JNI 함수를 호출할 때는 [그림 84]의 화살표 표시와 같이 동일한 함수명을 사용한다는 것이다. 
		(JAVA_com_playground_anditer_NativeDetector_ischeck <- isCheck())
		따라서, 이와 같은 두 가지 정보를 잘 활용한다면 분석에 소요되는 시간을 상당히 단축 시킬 수 있게 된다.
		
		java_com으로 시작하는 함수 검색
		isCheckRooting 함수 검색
		
		isCheckRooting() 함수의 코드 중 일부로 루팅 디바이스를 검사하기 위한 “/system/xbin/su”, “/xbin/su” 등의 파일 경로 문자열이 사용
		검사 시 사용된 문자열은 “basic_string” 생성자에 의해 호출된 “std::string” 클래스 객체 생성을 통해 “v0” 변수에 할당
		“v0” 변수는 sub_5C1B0() 함수의 인자로 전달되어 루팅 디바이스를 검사
		sub_5C1B0() 함수 호출 시 전달된 인자는 [그림 90]과 같이 fopen() 함수를 통해 디바이스에 파일이 존재하는지를 검사
		패키지 목록을 확인할 수 있으며, ② “std::string” 클래스 객체를 생성해 “v8” 변수에 할당
		std::operator+ 연산자를 통해 “pm list packages” 문자열과 “v8” 변수의 문자열을 연결하고 system() 함수를 호출해 Package Manager 명령어를 수행
		해당 패키지가 디바이스에 존재할 경우 루팅 디바이스로 탐지
		
		파일 기반
		Interceptor.attach(Module.findExportByName(null,"fopen"),{ 
		//Interceptor.attach()가 사용되었으며, 첫 번째 인자에는 후킹하고자 하는 함수의 주솟값이 전달 두 번째 인자로는 JavaScript 함수가 지정되어 후킹 함수로 동작
		//Module.findExportByName() 함수를 사용하여 현재 프로세스의 모든 모듈에서 fopen() 함수의 주소를 찾아 반환
			onEnter:function(args){
				this.checkFile=Memory.readCString(ptr(args[0]));
				const parsing= this.checkFile.split('/'); //함수 호출 시 전달되는 첫 번째 인자에서 파일 이름을 파싱
				const check=parsing[parsing.length -1]
				
				if(/su|superuser|busybox/gi.test(check)){ // 파일 이름에 “su”, “superuser”, ”busybox”와 같은 문자열이 포함되어 있는지를 검사
					Memory.writeUtf8String(args[0],"fake"); //문자열이 포함되어 있다면 파일 이름을 “fakeapp”으로 변조
				}
			},
			onLeave:fuunction(retval){
				retunr retval
			}
		})
		
		패키지 기반
		Interceptor.attach(Module.findExportByName(null,"system"),{ //Module.findExportByName() 함수를 사용하여 현재 프로세스의 모든 모듈에서 system() 함수의 주소를 찾아 반환
			onEnter: function(args){
				this.cmd=Memory.readCString(ptr(args[0]));
				if(this.cmd.includes("pm list")){
					Memory.writeUtf8String(args[0],"fakeapp")
				}//system() 함수 호출 시 전달되는 인자에서 “pm list”라는 문자열이 포함되어 있는지를 검사하고 ③ 만약 포함되어 있을 경우 해당 인자 값을 “fakeapp”으로 변조
				
			},
			onLeave:fuunction(retval){
				retunr retval
			}
		})
	
	
	Bypass Native(Rooting-Execution)
		“su” 파일의 위치를 찾기 위해 “which” 명령어를 사용한다. 만약 명령어 실행 결과로 파일의 경로를 반환받게 될 경우 디바이스가 루팅 된 것으로 판단해 탐지
		 System.loadLibray() 함수를 통해 “libanditer.so”라는 라이브러리 파일이 로드
		 
		IDA를 통해 “libanditer.so” 파일을 로드하고 Functions 뷰 패널에서 [그림 97]에서 확인한 함수명을 검색
		 isCheckExecution() 함수의 소스코드이다. 코드를 살펴보면 사용자 전환 시 사용되는 명령어인 “su”가 포함되어 있고 해당 문자열을 인자로 findExecutable() 함수를 호출하고 있다. 
		 이를 통해 추측해 볼수 있는 것은 findExecutable() 함수가 “su” 파일의 위치를 찾는 기능을 수행하는 함수
		
		findExecutable() 함수
		 std::operator+ 연결 연산자와 append() 함수를 사용하여 “which”, “2>/dev/null” 문자열과 결합
		결합된 문자열을 인자로 popen() 함수를 호출하여 쉘 명령어를 실행하고 그 결과를 읽어오게 된다. 
		따라서, popen() 함수의 실행 결과에 “su” 파일의 경로가 포함되어 있으면 루팅 디바이스로 탐지
		
		Interceptor.attach(Module.findExportByName(null,"popen"),{
			onEnter:function(args){
				this.cmd=Memory.readCString(ptr(args[0]));
				if(this.cmd.includes("which")){
					Memory.writeUtf8String(args[0],"fakeapp")
				}
			},
			onLeave:function(ret){return ret}
		})
		
	Bypass Native(Debug-Debuggable)
		System.loadLibray() 함수를 통해 로드된 라이브러리 파일인 “libanditer.so”을 분석
		 IDA를 통해 “libanditer.so” 파일을 로드하고 Functions 뷰 패널에서 [그림 104]에서 확인한 함수명(“isCheckDebuggable”)을 검색
		 
		
		 isCheckdebuggable() 함수의 소스코드이다. 코드를 살펴보면 ① 시스템 속성 정보를 가져올 때 사용하는 “getprop ro.debuggable”명령어가 사용되고 있으며, 
		 ② popen() 함수를 통해 해당 명령어의 결과를 받아오고 있다. 그리고 해당 결괏값을 인자로
		 ③ fgets() 함수를 호출하여 문자열로 읽어오고 그 값이 1인 경우 디버그 모드가 동작 중인 것으로 판단해 탐지
		 
		let reulst =false
		Interceptor.attach(Module.findExportByName(null,"fgets", { //Module.findExportByName() 함수를 사용하여 현재 프로세스의 모든 모듈에서 fgets() 함수의 주소를 찾아 반환
			onEnter:function(args){
				console.log("fget");
				const file=args[2] //popen 결과 v0 -> fgets(s,128,v0)
				const buffersize=1024;
				const buffer= Memory.alloc(buffersize); //파일 포인터가 가리키는 파일을 읽기 위해 메모리에 버퍼를 할당
				const fread=new NativeFunction(Module.findExportByName(null,'fread'), 'size_t', ['pointer','size_t','size_t','pointer']);
				// 데이터를 읽어 오기 위한 fread() 함수 객체를 생성
				const bytesRead=fread(buffer,1,buffersize,file);// 읽고, 지정된 buffer에 저장합니다. 파일의 위치는 읽은 바이트의 수만큼 증가
				// 읽기에 성공한 전체 항목의 수를 리턴
				
				const data =Memory.readUtf8String(buffer, bytesRead.toNumber()); // 문자열을 숫자로 변경, 읽을 만큼 다시 utf8로 읽어 데이터 저장
				if(data==1){ //파일에서 읽어온 데이터가 1이라면 변조를 위해 result 값을 true로 설정
					console.log(" detect ")
					result = true
				}
				
			},
			onLeave:function(retval){ //onLeave에서 result 값을 확인하여 true일 경우 fgets() 함수 결과에 대한 반환 값을 0(0x0)으로 변조
				if(result){
					retval.replace(0)
				}
			}
		})
		
	Bypass Native(Debug-TracerPID)
		System.loadLibray() 함수를 통해 로드된 라이브러리 파일인 “libanditer.so”을 분석
		 “libanditer.so” 파일을 로드하고 Functions 뷰 패널에서 [그림 110]에서 확인한 함수명(“isCheckTracerPID”)을 검색
		
		현재 실행 중인 앱의 프로세스 상태 정보를 확인하기 위해 fopen() 함수를 사용하여 “/proc/self/status” 파일을 열고 있는 것을 볼 수 있다. 
		② 그리고 std::string::compare() 함수를 통해 “/proc/self/status” 파일에서 가져온 데이터에서 “TracerPid:” 값을 추출하고,
		해당 값이 0이 아닌 경우 디버그 모드 사용자로 탐지
		 std::string::compare() 함수는 C++ std::string 클래스의 멤버 함수로서, 문자열 비교를 수행하는 기능을 가지고 있으며, 
		 우리가 살펴볼 “TracerPid:” 문자열은 해당 함수 호출 시 4번째 인자로 전달되어 “/proc/self/status” 파일의 데이터에서 문자열에 해당하는 값을 가져온
		
		std::string::compare() 함수를 후킹하기 위한 Frida 스크립트
			std::string::compare() 함수는 "libanditer.so" 라이브러리의 헤더 파일에서 호출되므로 해당 라이브러리 파일이 로딩되기 전에 std::string::compare() 함수를 후킹 하려고 시도하면 오류가 발생
			라이브러리 파일의 로딩을 감지하기 위한 코드가 필요
			
			const moduleName ="libanditer.so"
			let moduleLoad=0
			//모듈 이름과 로딩 상태를 확인하기 위한 변수를 지정
			
			Interceptor.attach(Module.findExportByName(null,"android_dlopen_ext"),{ //“android_dlopen_ext” 함수를 후킹
				onEnter:function(args){
					const path=Memory.readUtf8String(args[0]);
					if(path.indexof(moduleName) !=-1){ //라이브러리 파일을 볼러 올 때, 인자로 전달되는 라이브러리 경로에 “libanditer.so”가 포함되어 있는지 검사
						console.log("모듈호출 ",path)
						moduleLoad=1
					}
					
				},
				onLeave:function(args){
					if(moduleLoad==1){ //moduleLoad 값이 1이라면 라이브러리 파일이 로드되었음을 의미하므로 std::string::compare() 함수를 후킹하기 위한 함수를 호출
						moduleLoad=0
						hookNative();
					}
				}
			})
			function hookNative(){
				const functions="_ZNKSt6__ndk112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7compareEmmPKcm"
				//std::string::compare() 함수를 후킹하기 위해서는 해당 함수의 망간화된 이름(Name Mangling)을 사용해야 한다. 
				//망간화란 C++ 컴파일러가 충돌을 방지하기 위해 함수 이름과 함수의 매개변수 타입 및 반환 타입을 조합하여 고유한 심볼 이름을 생성하는 과정을 말한다. 
				//따라서, std::string::compare() 함수 이름을 그대로 사용하는 것이 아닌 [그림 113]에서 확인한 망간화된 이름을 지정
				Interceptor.attach(Module.findExportByName(moduleName, functions),{
				onEnter:function(args){
						const check= Memory.readUtf8String(args[3])//TracerPid: 문자열
						if(check.includes("TracerPid")){//함수로 전달되는 인자 중에서 4번째 인자에 비교를 위한 void * 타입의 문자열이 전달되며, 문자열에 “TracerPid”가 포함되어 있는지 확인하
							const fakevalue="fake"
							const newStringPtr= Memory.allocUtf8String(fakevalue);
							//변조하기 위한 “fakeapp” 문자열을 메모리에 할당하여 포인터를 반환
							args[3] = newStringPtr
							//반환받은 포인터를 4번째 인자에 재할당한다. 참고로 인자 타입이 포인터일 경우 
							[그림 101]과 같이 Memory.writeUtf8String() 함수를 사용한 문자열 작성은 사용하지 못한다. 따라서, 
							[그림 115] ④의 구문과 같이 재할당 방식을 사용
						}
				},
				onLeave:function(retval){ return retval}
				});
				
			}
			
			
	Bypass Native(Frida-Files)
		Frida 서버가 자동으로 생성하는 파일들이 위치한 디렉터리인 “/data/local/tmp”를 확인하여 Frida 관련 파일의 존재 여부를 검사한다. 따라서, 관련 파일이 해당 디렉터리에 존재할 경우 Frida 사용자로 탐지
		System.loadLibray() 함수를 통해 로드된 라이브러리 파일인 “libanditer.so”을 분석  확인한 함수명(“isCheckFridaFile”)을 검색
		
		opendir() 함수를 사용하여 “/data/local/tmp” 디렉터리의 스트림을 가져오고, 이를 통해 해당 디렉터리 내의 파일과 하위 디렉터리에 접근할 수 있게 된다. 
		②에서는 readdir() 함수를 사용하여 opendir() 함수를 통해 얻은 스트림 정보로부터 디렉터리 내의 파일과 디렉터리 정보를 순차적으로 읽어오며, 각 항목에서 “Frida”라는 문자열이 포함되어 있는지 검사
		
		Interceptor.attach(Module.findExportByName(null,"opendir"),{
			onEnter:function(args){
				this.path=Memory.readUtf8String(args[0]);
				if(this.path.includes("/data/local//tmp")){
					const fakedir=Memory.allocUtf8String("fakedir");
					args[0]=fakedir
				}
			},
			onLeave:function(retval){ return retval}
			});
		})
		
	Bypass Native(Frida-Port)
		디바이스에서 통신 중인 포트를 확인하기 위해 socket() 함수가 사용된 것을 볼 수 있다.
		첫 번째 인자로는 IPv4(AF_INET) 도메인 정보를 지정하고 
		두 번째 인자로는 소켓 타입인 TCP를 지정한다.
		세 번째 인자에는 TCP 기본 프로토콜 사용을 위한 값 0을 지정해 준다. 
		그리고 이렇게 생성된 소켓은 데이터를 송·수신할 수 있는 준비 상태가 되며, ② connect() 함수를 사용하여 바인딩하고 연결
		
		첫 번째는 소켓 생성을 방지하기 위한 socket() 함수를 후킹하는 방법이고 
		두 번째는 connect() 함수를 후킹하여 특정 주소로의 연결 시도에서 통신 성공 여부를 조작하는 방법이다. 
		그러나 첫 번째 방법은 단순히 통신 준비를 위한 소켓 생성 단계만을 대상으로 하기 때문에 특정 주소에 대한 변조가 제한적이며, 
		모든 소켓 생성 과정을 변조할 경우 애플리케이션에서 오류가 발생할 수 있다. 
		때문에, 이와 같은 통신 탐지를 우회하기 위한 대안으로는 connect() 함수를 후킹하는 방법이 가장 안정적이고 많이 사용되는 방법
		
		connect() 함수 호출 시 전달되는 sockaddr 구조체의 인스턴스
		*(_QWORD *)&addr.sa_family =0x10007FA2690002LL;
		v2= connect(v0, &addr, 16) !=-1;
		소켓을 생성하기 위해 socket() 함수를 사용하면, 통신을 위해 필요한 주소 정보를 담고 있는 “struct sockaddr” 구조체의 인스턴스가 필요하다.
		이 구조체는 IP 주소, 포트 번호 등의 정보를 포함하고 있으며, connect() 함수 호출 시 이 주소 정보를 참조하여 통신을 하게 된다. 
		여기서는 [그림 127]의 addr 변수가 “sockaddr” 구조체의 인스턴스로 사용되며, connect() 함수 호출 시 전달
		
		특정 주소로의 연결 시도에서 통신 성공 여부를 조작하기 위해서는 인자로 전달되는 “sockaddr” 구조체의 인스턴스에서 IP 주소, 포트 번호 등의 정보를 추출
		“sockaddr” 구조체 인스턴스를 출력하는 코드
		connect() 함수로 전달되는 두 번째 인자인 “sockaddr” 구조체를 변수에 저장하고 구조체의 크기를 지정한다. ②에서는 지정한 크기만큼의 바이트를 구조체에서 읽어와 패킷 데이터를 저장
			Interceptor.attach(Module.findExportByName(null,"connect"),{
				onEnter:function(args){
					const addrArg=args[1];
					const size=108;
					const addrData=Memory.readByteArray(addrArg,size);
					console.log("\n 구조체 인스턴트 정보 \n", addrData);
					
				},
				onLeave:function(retval){return retval}
			})
			
			hex 로 이루어진 결과값 반환되는
			“sockaddr” 구조체의 구조로 3 ~ 8번째(0x02~0x07) 바이트에는 통신 연결을 시도하려는 대상의 주소 정보가 저장
			앞의 2바이트는 포트 번호를 나타내고, 뒤의 4바이트는 IP 주소를 나타낸다. 따라서, 이를 10진수로 변환하면 127.0.0.1의 루프 백 주소와 27042 포트 번호
			
		let result = false //전역 변수를 지정하여 루프 백 주소 및 Frida 기본 포트에 대한 통신 유무를 확인
		Interceptor.attach(Module.findExportByName(null,"connect"),{
			onEnter:function(args){
			const addrArg=args[1];
			const size=108;
			const addrData=Memory.readByteArray(addrArg,size);
			//“sockaddr” 구조체 정보를 가져온다
			
			const ipBytes= Array.from(new Uint8Array(addrData.slice(4,8)));
			const portBytes= Array.from(new Unit8Array(addrData.slice(2,4)));
			//가져온 데이터에서 IP 주소 및 포트 번호가 저장된 값을 필드 값을 파싱
			
			const portHex= portBytes.map(function(byte){return byte.toString(16);})
			const portNumber = parseInt((portHex[0]+portHex[1],1),16); 
			//포트 번호에 대한 16진수 값을 10진수로 변환
			
			let ipaddress="";
			for(var i=0;i<ipBytes.length; i++){
				ipaddress+= ipBytes[i]
				if(i< ipBytes.length -1){
				ipaddress+=".";
				}
				//IP 주소 필드 값에서 실제 IP 주소를 추출
			}
			if(ipaddress=="127.0.0.1" && portNumber=="27042"){ //추출한 IP 주소와 포트 번호가 루프 백 주소 및 Frida 기본 포트와 일치한다면, 전역 변수를 true로 설정

				result=true
			}
		},
		onLeave: function(retval){
			if(result){
				retval.replace(0xffffffff) //결괏값이 true인 경우, 통신 성공에 대한 결괏값을 변조한다. “0xffffffff”는 10진수 “-1”을 의미하며, 이는 통신이 실패
				결과값출력
			}
			return retval
		}


frida -w (await) attach 정지후 실행
